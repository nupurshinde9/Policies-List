{"version":3,"sources":["/Users/abhishekkargawal/Documents/Nupur/policies-list/PolicyClient/node_modules/@angular/flex-layout/esm2015/extended.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgKC,q7BASC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAwBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4KD,moCASC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBA2BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuSD,i2DAcC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAuCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsWD,wmCASC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBA0BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuCD;;;;;;;;;;;;;;;0BAOC","file":"extended.js","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, ElementRef, Input, Inject, Optional, PLATFORM_ID, IterableDiffers, KeyValueDiffers, Renderer2, Self, SecurityContext, NgModule } from '@angular/core';\nimport { isPlatformServer, NgClass, NgStyle } from '@angular/common';\nimport { BaseDirective, MediaMonitor, SERVER_TOKEN, StyleUtils, BaseDirectiveAdapter, CoreModule } from '@angular/flex-layout/core';\nimport { LayoutDirective } from '@angular/flex-layout/flex';\nimport { DomSanitizer } from '@angular/platform-browser';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * This directive provides a responsive API for the HTML <img> 'src' attribute\n * and will update the img.src property upon each responsive activation.\n *\n * e.g.\n *      <img src=\"defaultScene.jpg\" src.xs=\"mobileScene.jpg\"></img>\n *\n * @see https://css-tricks.com/responsive-images-youre-just-changing-resolutions-use-src/\n */\nclass ImgSrcDirective extends BaseDirective {\n    /**\n     * @param {?} _elRef\n     * @param {?} _monitor\n     * @param {?} _styler\n     * @param {?} _platformId\n     * @param {?} _serverModuleLoaded\n     */\n    constructor(_elRef, _monitor, _styler, _platformId, _serverModuleLoaded) {\n        super(_monitor, _elRef, _styler);\n        this._elRef = _elRef;\n        this._monitor = _monitor;\n        this._styler = _styler;\n        this._platformId = _platformId;\n        this._serverModuleLoaded = _serverModuleLoaded;\n        this._cacheInput('src', _elRef.nativeElement.getAttribute('src') || '');\n        if (isPlatformServer(this._platformId) && this._serverModuleLoaded) {\n            this.nativeElement.setAttribute('src', '');\n        }\n    }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set srcBase(val) { this.cacheDefaultSrc(val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set srcXs(val) { this._cacheInput('srcXs', val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set srcSm(val) { this._cacheInput('srcSm', val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set srcMd(val) { this._cacheInput('srcMd', val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set srcLg(val) { this._cacheInput('srcLg', val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set srcXl(val) { this._cacheInput('srcXl', val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set srcLtSm(val) { this._cacheInput('srcLtSm', val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set srcLtMd(val) { this._cacheInput('srcLtMd', val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set srcLtLg(val) { this._cacheInput('srcLtLg', val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set srcLtXl(val) { this._cacheInput('srcLtXl', val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set srcGtXs(val) { this._cacheInput('srcGtXs', val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set srcGtSm(val) { this._cacheInput('srcGtSm', val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set srcGtMd(val) { this._cacheInput('srcGtMd', val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set srcGtLg(val) { this._cacheInput('srcGtLg', val); }\n    /**\n     * Listen for responsive changes to update the img.src attribute\n     * @return {?}\n     */\n    ngOnInit() {\n        super.ngOnInit();\n        if (this.hasResponsiveKeys) {\n            // Listen for responsive changes\n            this._listenForMediaQueryChanges('src', this.defaultSrc, () => {\n                this._updateSrcFor();\n            });\n        }\n        this._updateSrcFor();\n    }\n    /**\n     * Update the 'src' property of the host <img> element\n     * @return {?}\n     */\n    ngOnChanges() {\n        if (this.hasInitialized) {\n            this._updateSrcFor();\n        }\n    }\n    /**\n     * Use the [responsively] activated input value to update\n     * the host img src attribute or assign a default `img.src=''`\n     * if the src has not been defined.\n     *\n     * Do nothing to standard `<img src=\"\">` usages, only when responsive\n     * keys are present do we actually call `setAttribute()`\n     * @return {?}\n     */\n    _updateSrcFor() {\n        if (this.hasResponsiveKeys) {\n            /** @type {?} */\n            let url = this.activatedValue || this.defaultSrc;\n            if (isPlatformServer(this._platformId) && this._serverModuleLoaded) {\n                this._styler.applyStyleToElement(this.nativeElement, { 'content': url ? `url(${url})` : '' });\n            }\n            else {\n                this.nativeElement.setAttribute('src', String(url));\n            }\n        }\n    }\n    /**\n     * Cache initial value of 'src', this will be used as fallback when breakpoint\n     * activations change.\n     * NOTE: The default 'src' property is not bound using \\@Input(), so perform\n     * a post-ngOnInit() lookup of the default src value (if any).\n     * @param {?=} value\n     * @return {?}\n     */\n    cacheDefaultSrc(value) {\n        this._cacheInput('src', value || '');\n    }\n    /**\n     * Empty values are maintained, undefined values are exposed as ''\n     * @return {?}\n     */\n    get defaultSrc() {\n        return this._queryInput('src') || '';\n    }\n    /**\n     * Does the <img> have 1 or more src.<xxx> responsive inputs\n     * defined... these will be mapped to activated breakpoints.\n     * @return {?}\n     */\n    get hasResponsiveKeys() {\n        return Object.keys(this._inputMap).length > 1;\n    }\n}\nImgSrcDirective.decorators = [\n    { type: Directive, args: [{\n                selector: `\n  img[src.xs],    img[src.sm],    img[src.md],    img[src.lg],   img[src.xl],\n  img[src.lt-sm], img[src.lt-md], img[src.lt-lg], img[src.lt-xl],\n  img[src.gt-xs], img[src.gt-sm], img[src.gt-md], img[src.gt-lg]\n`\n            },] },\n];\n/** @nocollapse */\nImgSrcDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: MediaMonitor },\n    { type: StyleUtils },\n    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },\n    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [SERVER_TOKEN,] }] }\n];\nImgSrcDirective.propDecorators = {\n    srcBase: [{ type: Input, args: ['src',] }],\n    srcXs: [{ type: Input, args: ['src.xs',] }],\n    srcSm: [{ type: Input, args: ['src.sm',] }],\n    srcMd: [{ type: Input, args: ['src.md',] }],\n    srcLg: [{ type: Input, args: ['src.lg',] }],\n    srcXl: [{ type: Input, args: ['src.xl',] }],\n    srcLtSm: [{ type: Input, args: ['src.lt-sm',] }],\n    srcLtMd: [{ type: Input, args: ['src.lt-md',] }],\n    srcLtLg: [{ type: Input, args: ['src.lt-lg',] }],\n    srcLtXl: [{ type: Input, args: ['src.lt-xl',] }],\n    srcGtXs: [{ type: Input, args: ['src.gt-xs',] }],\n    srcGtSm: [{ type: Input, args: ['src.gt-sm',] }],\n    srcGtMd: [{ type: Input, args: ['src.gt-md',] }],\n    srcGtLg: [{ type: Input, args: ['src.gt-lg',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Directive to add responsive support for ngClass.\n * This maintains the core functionality of 'ngClass' and adds responsive API\n * Note: this class is a no-op when rendered on the server\n */\nclass ClassDirective extends BaseDirective {\n    /**\n     * @param {?} monitor\n     * @param {?} _iterableDiffers\n     * @param {?} _keyValueDiffers\n     * @param {?} _ngEl\n     * @param {?} _renderer\n     * @param {?} _ngClassInstance\n     * @param {?} _styler\n     */\n    constructor(monitor, _iterableDiffers, _keyValueDiffers, _ngEl, _renderer, _ngClassInstance, _styler) {\n        super(monitor, _ngEl, _styler);\n        this.monitor = monitor;\n        this._iterableDiffers = _iterableDiffers;\n        this._keyValueDiffers = _keyValueDiffers;\n        this._ngEl = _ngEl;\n        this._renderer = _renderer;\n        this._ngClassInstance = _ngClassInstance;\n        this._styler = _styler;\n        this._base = new BaseDirectiveAdapter('ngClass', this.monitor, this._ngEl, this._styler);\n        if (!this._ngClassInstance) {\n            // Create an instance NgClass Directive instance only if `ngClass=\"\"` has NOT been defined on\n            // the same host element; since the responsive variations may be defined...\n            this._ngClassInstance = new NgClass(this._iterableDiffers, this._keyValueDiffers, this._ngEl, this._renderer);\n        }\n    }\n    /**\n     * Intercept ngClass assignments so we cache the default classes\n     * which are merged with activated styles or used as fallbacks.\n     * Note: Base ngClass values are applied during ngDoCheck()\n     * @param {?} val\n     * @return {?}\n     */\n    set ngClassBase(val) {\n        /** @type {?} */\n        const key = 'ngClass';\n        this._base.cacheInput(key, val, true);\n        this._ngClassInstance.ngClass = this._base.queryInput(key);\n    }\n    /**\n     * Capture class assignments so we cache the default classes\n     * which are merged with activated styles and used as fallbacks.\n     * @param {?} val\n     * @return {?}\n     */\n    set klazz(val) {\n        /** @type {?} */\n        const key = 'class';\n        this._base.cacheInput(key, val);\n        this._ngClassInstance.klass = val;\n    }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set ngClassXs(val) { this._base.cacheInput('ngClassXs', val, true); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set ngClassSm(val) { this._base.cacheInput('ngClassSm', val, true); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set ngClassMd(val) { this._base.cacheInput('ngClassMd', val, true); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set ngClassLg(val) { this._base.cacheInput('ngClassLg', val, true); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set ngClassXl(val) { this._base.cacheInput('ngClassXl', val, true); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set ngClassLtSm(val) { this._base.cacheInput('ngClassLtSm', val, true); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set ngClassLtMd(val) { this._base.cacheInput('ngClassLtMd', val, true); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set ngClassLtLg(val) { this._base.cacheInput('ngClassLtLg', val, true); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set ngClassLtXl(val) { this._base.cacheInput('ngClassLtXl', val, true); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set ngClassGtXs(val) { this._base.cacheInput('ngClassGtXs', val, true); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set ngClassGtSm(val) { this._base.cacheInput('ngClassGtSm', val, true); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set ngClassGtMd(val) { this._base.cacheInput('ngClassGtMd', val, true); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set ngClassGtLg(val) { this._base.cacheInput('ngClassGtLg', val, true); }\n    /**\n     * For \\@Input changes on the current mq activation property\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (this._base.activeKey in changes) {\n            this._ngClassInstance.ngClass = this._base.mqActivation.activatedInput || '';\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        this._configureMQListener();\n    }\n    /**\n     * For ChangeDetectionStrategy.onPush and ngOnChanges() updates\n     * @return {?}\n     */\n    ngDoCheck() {\n        this._ngClassInstance.ngDoCheck();\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._base.ngOnDestroy();\n    }\n    /**\n     * Build an mqActivation object that bridges mql change events to onMediaQueryChange handlers\n     * NOTE: We delegate subsequent activity to the NgClass logic\n     *       Identify the activated input value and update the ngClass iterables...\n     *       Use ngDoCheck() to actually apply the values to the element\n     * @param {?=} baseKey\n     * @return {?}\n     */\n    _configureMQListener(baseKey = 'ngClass') {\n        /** @type {?} */\n        const fallbackValue = this._base.queryInput(baseKey);\n        this._base.listenForMediaQueryChanges(baseKey, fallbackValue, (changes) => {\n            this._ngClassInstance.ngClass = changes.value || '';\n            this._ngClassInstance.ngDoCheck();\n        });\n    }\n}\nClassDirective.decorators = [\n    { type: Directive, args: [{\n                selector: `\n    [ngClass.xs], [ngClass.sm], [ngClass.md], [ngClass.lg], [ngClass.xl],\n    [ngClass.lt-sm], [ngClass.lt-md], [ngClass.lt-lg], [ngClass.lt-xl],\n    [ngClass.gt-xs], [ngClass.gt-sm], [ngClass.gt-md], [ngClass.gt-lg]\n  `\n            },] },\n];\n/** @nocollapse */\nClassDirective.ctorParameters = () => [\n    { type: MediaMonitor },\n    { type: IterableDiffers },\n    { type: KeyValueDiffers },\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: NgClass, decorators: [{ type: Optional }, { type: Self }] },\n    { type: StyleUtils }\n];\nClassDirective.propDecorators = {\n    ngClassBase: [{ type: Input, args: ['ngClass',] }],\n    klazz: [{ type: Input, args: ['class',] }],\n    ngClassXs: [{ type: Input, args: ['ngClass.xs',] }],\n    ngClassSm: [{ type: Input, args: ['ngClass.sm',] }],\n    ngClassMd: [{ type: Input, args: ['ngClass.md',] }],\n    ngClassLg: [{ type: Input, args: ['ngClass.lg',] }],\n    ngClassXl: [{ type: Input, args: ['ngClass.xl',] }],\n    ngClassLtSm: [{ type: Input, args: ['ngClass.lt-sm',] }],\n    ngClassLtMd: [{ type: Input, args: ['ngClass.lt-md',] }],\n    ngClassLtLg: [{ type: Input, args: ['ngClass.lt-lg',] }],\n    ngClassLtXl: [{ type: Input, args: ['ngClass.lt-xl',] }],\n    ngClassGtXs: [{ type: Input, args: ['ngClass.gt-xs',] }],\n    ngClassGtSm: [{ type: Input, args: ['ngClass.gt-sm',] }],\n    ngClassGtMd: [{ type: Input, args: ['ngClass.gt-md',] }],\n    ngClassGtLg: [{ type: Input, args: ['ngClass.gt-lg',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst FALSY = ['false', false, 0];\n/**\n * For fxHide selectors, we invert the 'value'\n * and assign to the equivalent fxShow selector cache\n *  - When 'hide' === '' === true, do NOT show the element\n *  - When 'hide' === false or 0... we WILL show the element\n * @param {?} hide\n * @return {?}\n */\nfunction negativeOf(hide) {\n    return (hide === '') ? false :\n        ((hide === 'false') || (hide === 0)) ? true : !hide;\n}\n/**\n * 'show' Layout API directive\n *\n */\nclass ShowHideDirective extends BaseDirective {\n    /**\n     * @param {?} monitor\n     * @param {?} layout\n     * @param {?} elRef\n     * @param {?} styleUtils\n     * @param {?} platformId\n     * @param {?} serverModuleLoaded\n     */\n    constructor(monitor, layout, elRef, styleUtils, platformId, serverModuleLoaded) {\n        super(monitor, elRef, styleUtils);\n        this.layout = layout;\n        this.elRef = elRef;\n        this.styleUtils = styleUtils;\n        this.platformId = platformId;\n        this.serverModuleLoaded = serverModuleLoaded;\n        /**\n         * Original dom Elements CSS display style\n         */\n        this._display = '';\n        if (layout) {\n            /**\n                   * The Layout can set the display:flex (and incorrectly affect the Hide/Show directives.\n                   * Whenever Layout [on the same element] resets its CSS, then update the Hide/Show CSS\n                   */\n            this._layoutWatcher = layout.layout$.subscribe(() => this._updateWithValue());\n        }\n    }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set show(val) { this._cacheInput('show', val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set showXs(val) { this._cacheInput('showXs', val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set showSm(val) { this._cacheInput('showSm', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set showMd(val) { this._cacheInput('showMd', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set showLg(val) { this._cacheInput('showLg', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set showXl(val) { this._cacheInput('showXl', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set showLtSm(val) { this._cacheInput('showLtSm', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set showLtMd(val) { this._cacheInput('showLtMd', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set showLtLg(val) { this._cacheInput('showLtLg', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set showLtXl(val) { this._cacheInput('showLtXl', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set showGtXs(val) { this._cacheInput('showGtXs', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set showGtSm(val) { this._cacheInput('showGtSm', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set showGtMd(val) { this._cacheInput('showGtMd', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set showGtLg(val) { this._cacheInput('showGtLg', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set hide(val) { this._cacheInput('show', negativeOf(val)); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set hideXs(val) { this._cacheInput('showXs', negativeOf(val)); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set hideSm(val) { this._cacheInput('showSm', negativeOf(val)); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set hideMd(val) { this._cacheInput('showMd', negativeOf(val)); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set hideLg(val) { this._cacheInput('showLg', negativeOf(val)); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set hideXl(val) { this._cacheInput('showXl', negativeOf(val)); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set hideLtSm(val) { this._cacheInput('showLtSm', negativeOf(val)); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set hideLtMd(val) { this._cacheInput('showLtMd', negativeOf(val)); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set hideLtLg(val) { this._cacheInput('showLtLg', negativeOf(val)); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set hideLtXl(val) { this._cacheInput('showLtXl', negativeOf(val)); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set hideGtXs(val) { this._cacheInput('showGtXs', negativeOf(val)); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set hideGtSm(val) { this._cacheInput('showGtSm', negativeOf(val)); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set hideGtMd(val) { this._cacheInput('showGtMd', negativeOf(val)); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set hideGtLg(val) { this._cacheInput('showGtLg', negativeOf(val)); }\n    ;\n    /**\n     * Override accessor to the current HTMLElement's `display` style\n     * Note: Show/Hide will not change the display to 'flex' but will set it to 'block'\n     * unless it was already explicitly specified inline or in a CSS stylesheet.\n     * @return {?}\n     */\n    _getDisplayStyle() {\n        return this.layout ? 'flex' : super._getDisplayStyle();\n    }\n    /**\n     * On changes to any \\@Input properties...\n     * Default to use the non-responsive Input value ('fxShow')\n     * Then conditionally override with the mq-activated Input's current value\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (this.hasInitialized && (changes['show'] != null || this._mqActivation)) {\n            this._updateWithValue();\n        }\n    }\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n    ngOnInit() {\n        super.ngOnInit();\n        this._display = this._getDisplayStyle();\n        /** @type {?} */\n        let value = this._getDefaultVal('show', true);\n        // Build _mqActivation controller\n        this._listenForMediaQueryChanges('show', value, (changes) => {\n            this._updateWithValue(changes.value);\n        });\n        this._updateWithValue();\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        super.ngOnDestroy();\n        if (this._layoutWatcher) {\n            this._layoutWatcher.unsubscribe();\n        }\n    }\n    /**\n     * Validate the visibility value and then update the host's inline display style\n     * @param {?=} value\n     * @return {?}\n     */\n    _updateWithValue(value) {\n        value = value || this._getDefaultVal('show', true);\n        if (this._mqActivation) {\n            value = this._mqActivation.activatedInput;\n        }\n        /** @type {?} */\n        let shouldShow = this._validateTruthy(value);\n        this._applyStyleToElement(this._buildCSS(shouldShow));\n        if (isPlatformServer(this.platformId) && this.serverModuleLoaded) {\n            this.nativeElement.style.setProperty('display', '');\n        }\n    }\n    /**\n     * Build the CSS that should be assigned to the element instance\n     * @param {?} show\n     * @return {?}\n     */\n    _buildCSS(show) {\n        return { 'display': show ? this._display : 'none' };\n    }\n    /**\n     * Validate the to be not FALSY\n     * @param {?=} show\n     * @return {?}\n     */\n    _validateTruthy(show = '') {\n        return (FALSY.indexOf(show) === -1);\n    }\n}\nShowHideDirective.decorators = [\n    { type: Directive, args: [{\n                selector: `\n  [fxShow],\n  [fxShow.xs], [fxShow.sm], [fxShow.md], [fxShow.lg], [fxShow.xl],\n  [fxShow.lt-sm], [fxShow.lt-md], [fxShow.lt-lg], [fxShow.lt-xl],\n  [fxShow.gt-xs], [fxShow.gt-sm], [fxShow.gt-md], [fxShow.gt-lg],\n  [fxHide],\n  [fxHide.xs], [fxHide.sm], [fxHide.md], [fxHide.lg], [fxHide.xl],\n  [fxHide.lt-sm], [fxHide.lt-md], [fxHide.lt-lg], [fxHide.lt-xl],\n  [fxHide.gt-xs], [fxHide.gt-sm], [fxHide.gt-md], [fxHide.gt-lg]\n`\n            },] },\n];\n/** @nocollapse */\nShowHideDirective.ctorParameters = () => [\n    { type: MediaMonitor },\n    { type: LayoutDirective, decorators: [{ type: Optional }, { type: Self }] },\n    { type: ElementRef },\n    { type: StyleUtils },\n    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },\n    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [SERVER_TOKEN,] }] }\n];\nShowHideDirective.propDecorators = {\n    show: [{ type: Input, args: ['fxShow',] }],\n    showXs: [{ type: Input, args: ['fxShow.xs',] }],\n    showSm: [{ type: Input, args: ['fxShow.sm',] }],\n    showMd: [{ type: Input, args: ['fxShow.md',] }],\n    showLg: [{ type: Input, args: ['fxShow.lg',] }],\n    showXl: [{ type: Input, args: ['fxShow.xl',] }],\n    showLtSm: [{ type: Input, args: ['fxShow.lt-sm',] }],\n    showLtMd: [{ type: Input, args: ['fxShow.lt-md',] }],\n    showLtLg: [{ type: Input, args: ['fxShow.lt-lg',] }],\n    showLtXl: [{ type: Input, args: ['fxShow.lt-xl',] }],\n    showGtXs: [{ type: Input, args: ['fxShow.gt-xs',] }],\n    showGtSm: [{ type: Input, args: ['fxShow.gt-sm',] }],\n    showGtMd: [{ type: Input, args: ['fxShow.gt-md',] }],\n    showGtLg: [{ type: Input, args: ['fxShow.gt-lg',] }],\n    hide: [{ type: Input, args: ['fxHide',] }],\n    hideXs: [{ type: Input, args: ['fxHide.xs',] }],\n    hideSm: [{ type: Input, args: ['fxHide.sm',] }],\n    hideMd: [{ type: Input, args: ['fxHide.md',] }],\n    hideLg: [{ type: Input, args: ['fxHide.lg',] }],\n    hideXl: [{ type: Input, args: ['fxHide.xl',] }],\n    hideLtSm: [{ type: Input, args: ['fxHide.lt-sm',] }],\n    hideLtMd: [{ type: Input, args: ['fxHide.lt-md',] }],\n    hideLtLg: [{ type: Input, args: ['fxHide.lt-lg',] }],\n    hideLtXl: [{ type: Input, args: ['fxHide.lt-xl',] }],\n    hideGtXs: [{ type: Input, args: ['fxHide.gt-xs',] }],\n    hideGtSm: [{ type: Input, args: ['fxHide.gt-sm',] }],\n    hideGtMd: [{ type: Input, args: ['fxHide.gt-md',] }],\n    hideGtLg: [{ type: Input, args: ['fxHide.gt-lg',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Extends an object with the *enumerable* and *own* properties of one or more source objects,\n * similar to Object.assign.\n *\n * @param {?} dest The object which will have properties copied to it.\n * @param {...?} sources The source objects from which properties will be copied.\n * @return {?}\n */\nfunction extendObject(dest, ...sources) {\n    if (dest == null) {\n        throw TypeError('Cannot convert undefined or null to object');\n    }\n    for (let source of sources) {\n        if (source != null) {\n            for (let key in source) {\n                if (source.hasOwnProperty(key)) {\n                    dest[key] = source[key];\n                }\n            }\n        }\n    }\n    return dest;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * NgStyle allowed inputs\n */\nclass NgStyleKeyValue {\n    /**\n     * @param {?} key\n     * @param {?} value\n     * @param {?=} noQuotes\n     */\n    constructor(key, value, noQuotes = true) {\n        this.key = key;\n        this.value = value;\n        this.key = noQuotes ? key.replace(/['\"]/g, '').trim() : key.trim();\n        this.value = noQuotes ? value.replace(/['\"]/g, '').trim() : value.trim();\n        this.value = this.value.replace(/;/, '');\n    }\n}\n/**\n * @param {?} target\n * @return {?}\n */\nfunction getType(target) {\n    /** @type {?} */\n    let what = typeof target;\n    if (what === 'object') {\n        return (target.constructor === Array) ? 'array' :\n            (target.constructor === Set) ? 'set' : 'object';\n    }\n    return what;\n}\n/**\n * Split string of key:value pairs into Array of k-v pairs\n * e.g.  'key:value; key:value; key:value;' -> ['key:value',...]\n * @param {?} source\n * @param {?=} delimiter\n * @return {?}\n */\nfunction buildRawList(source, delimiter = ';') {\n    return String(source)\n        .trim()\n        .split(delimiter)\n        .map((val) => val.trim())\n        .filter(val => val !== '');\n}\n/**\n * Convert array of key:value strings to a iterable map object\n * @param {?} styles\n * @param {?=} sanitize\n * @return {?}\n */\nfunction buildMapFromList(styles, sanitize) {\n    /** @type {?} */\n    const sanitizeValue = (it) => {\n        if (sanitize) {\n            it.value = sanitize(it.value);\n        }\n        return it;\n    };\n    return styles\n        .map(stringToKeyValue)\n        .filter(entry => !!entry)\n        .map(sanitizeValue)\n        .reduce(keyValuesToMap, /** @type {?} */ ({}));\n}\n/**\n * Convert Set<string> or raw Object to an iterable NgStyleMap\n * @param {?} source\n * @param {?=} sanitize\n * @return {?}\n */\nfunction buildMapFromSet(source, sanitize) {\n    /** @type {?} */\n    let list = [];\n    if (getType(source) === 'set') {\n        (/** @type {?} */ (source)).forEach(entry => list.push(entry));\n    }\n    else {\n        Object.keys(source).forEach((key) => {\n            list.push(`${key}:${((/** @type {?} */ (source)))[key]}`);\n        });\n    }\n    return buildMapFromList(list, sanitize);\n}\n/**\n * Convert 'key:value' -> [key, value]\n * @param {?} it\n * @return {?}\n */\nfunction stringToKeyValue(it) {\n    let [key, val] = it.split(':');\n    return new NgStyleKeyValue(key, val);\n}\n/**\n * Convert [ [key,value] ] -> { key : value }\n * @param {?} map\n * @param {?} entry\n * @return {?}\n */\nfunction keyValuesToMap(map, entry) {\n    if (!!entry.key) {\n        map[entry.key] = entry.value;\n    }\n    return map;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Directive to add responsive support for ngStyle.\n *\n */\nclass StyleDirective extends BaseDirective {\n    /**\n     *  Constructor for the ngStyle subclass; which adds selectors and\n     *  a MediaQuery Activation Adapter\n     * @param {?} monitor\n     * @param {?} _sanitizer\n     * @param {?} _ngEl\n     * @param {?} _renderer\n     * @param {?} _differs\n     * @param {?} _ngStyleInstance\n     * @param {?} _styler\n     */\n    constructor(monitor, _sanitizer, _ngEl, _renderer, _differs, _ngStyleInstance, _styler) {\n        super(monitor, _ngEl, _styler);\n        this.monitor = monitor;\n        this._sanitizer = _sanitizer;\n        this._ngEl = _ngEl;\n        this._renderer = _renderer;\n        this._differs = _differs;\n        this._ngStyleInstance = _ngStyleInstance;\n        this._styler = _styler;\n        this._base = new BaseDirectiveAdapter('ngStyle', this.monitor, this._ngEl, this._styler);\n        if (!this._ngStyleInstance) {\n            // Create an instance NgClass Directive instance only if `ngClass=\"\"` has NOT been\n            // defined on the same host element; since the responsive variations may be defined...\n            this._ngStyleInstance = new NgStyle(this._differs, this._ngEl, this._renderer);\n        }\n        this._buildCacheInterceptor();\n        this._fallbackToStyle();\n    }\n    /**\n     * Intercept ngStyle assignments so we cache the default styles\n     * which are merged with activated styles or used as fallbacks.\n     * @param {?} val\n     * @return {?}\n     */\n    set ngStyleBase(val) {\n        /** @type {?} */\n        const key = 'ngStyle';\n        this._base.cacheInput(key, val, true); // convert val to hashmap\n        this._ngStyleInstance.ngStyle = this._base.queryInput(key);\n    }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set ngStyleXs(val) { this._base.cacheInput('ngStyleXs', val, true); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set ngStyleSm(val) { this._base.cacheInput('ngStyleSm', val, true); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set ngStyleMd(val) { this._base.cacheInput('ngStyleMd', val, true); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set ngStyleLg(val) { this._base.cacheInput('ngStyleLg', val, true); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set ngStyleXl(val) { this._base.cacheInput('ngStyleXl', val, true); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set ngStyleLtSm(val) { this._base.cacheInput('ngStyleLtSm', val, true); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set ngStyleLtMd(val) { this._base.cacheInput('ngStyleLtMd', val, true); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set ngStyleLtLg(val) { this._base.cacheInput('ngStyleLtLg', val, true); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set ngStyleLtXl(val) { this._base.cacheInput('ngStyleLtXl', val, true); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set ngStyleGtXs(val) { this._base.cacheInput('ngStyleGtXs', val, true); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set ngStyleGtSm(val) { this._base.cacheInput('ngStyleGtSm', val, true); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set ngStyleGtMd(val) { this._base.cacheInput('ngStyleGtMd', val, true); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set ngStyleGtLg(val) { this._base.cacheInput('ngStyleGtLg', val, true); }\n    ;\n    /**\n     * For \\@Input changes on the current mq activation property\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (this._base.activeKey in changes) {\n            this._ngStyleInstance.ngStyle = this._base.mqActivation.activatedInput || '';\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        this._configureMQListener();\n    }\n    /**\n     * For ChangeDetectionStrategy.onPush and ngOnChanges() updates\n     * @return {?}\n     */\n    ngDoCheck() {\n        this._ngStyleInstance.ngDoCheck();\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._base.ngOnDestroy();\n    }\n    /**\n     * Build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @param {?=} baseKey\n     * @return {?}\n     */\n    _configureMQListener(baseKey = 'ngStyle') {\n        /** @type {?} */\n        const fallbackValue = this._base.queryInput(baseKey);\n        this._base.listenForMediaQueryChanges(baseKey, fallbackValue, (changes) => {\n            this._ngStyleInstance.ngStyle = changes.value || '';\n            this._ngStyleInstance.ngDoCheck();\n        });\n    }\n    /**\n     * Build intercept to convert raw strings to ngStyleMap\n     * @return {?}\n     */\n    _buildCacheInterceptor() {\n        /** @type {?} */\n        let cacheInput = this._base.cacheInput.bind(this._base);\n        this._base.cacheInput = (key, source, cacheRaw = false, merge = true) => {\n            /** @type {?} */\n            let styles = this._buildStyleMap(source);\n            if (merge) {\n                styles = extendObject({}, this._base.inputMap['ngStyle'], styles);\n            }\n            cacheInput(key, styles, cacheRaw);\n        };\n    }\n    /**\n     * Convert raw strings to ngStyleMap; which is required by ngStyle\n     * NOTE: Raw string key-value pairs MUST be delimited by `;`\n     *       Comma-delimiters are not supported due to complexities of\n     *       possible style values such as `rgba(x,x,x,x)` and others\n     * @param {?} styles\n     * @return {?}\n     */\n    _buildStyleMap(styles) {\n        /** @type {?} */\n        let sanitizer = (val) => {\n            // Always safe-guard (aka sanitize) style property values\n            return this._sanitizer.sanitize(SecurityContext.STYLE, val) || '';\n        };\n        if (styles) {\n            switch (getType(styles)) {\n                case 'string': return buildMapFromList$1(buildRawList(styles), sanitizer);\n                case 'array': return buildMapFromList$1(/** @type {?} */ (styles), sanitizer);\n                case 'set': return buildMapFromSet(styles, sanitizer);\n                default: return buildMapFromSet(styles, sanitizer);\n            }\n        }\n        return styles;\n    }\n    /**\n     * Initial lookup of raw 'class' value (if any)\n     * @return {?}\n     */\n    _fallbackToStyle() {\n        if (!this._base.queryInput('ngStyle')) {\n            this.ngStyleBase = this._getAttributeValue('style') || '';\n        }\n    }\n}\nStyleDirective.decorators = [\n    { type: Directive, args: [{\n                selector: `\n    [ngStyle.xs], [ngStyle.sm], [ngStyle.md], [ngStyle.lg], [ngStyle.xl],\n    [ngStyle.lt-sm], [ngStyle.lt-md], [ngStyle.lt-lg], [ngStyle.lt-xl],\n    [ngStyle.gt-xs], [ngStyle.gt-sm], [ngStyle.gt-md], [ngStyle.gt-lg]\n  `\n            },] },\n];\n/** @nocollapse */\nStyleDirective.ctorParameters = () => [\n    { type: MediaMonitor },\n    { type: DomSanitizer },\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: KeyValueDiffers },\n    { type: NgStyle, decorators: [{ type: Optional }, { type: Self }] },\n    { type: StyleUtils }\n];\nStyleDirective.propDecorators = {\n    ngStyleBase: [{ type: Input, args: ['ngStyle',] }],\n    ngStyleXs: [{ type: Input, args: ['ngStyle.xs',] }],\n    ngStyleSm: [{ type: Input, args: ['ngStyle.sm',] }],\n    ngStyleMd: [{ type: Input, args: ['ngStyle.md',] }],\n    ngStyleLg: [{ type: Input, args: ['ngStyle.lg',] }],\n    ngStyleXl: [{ type: Input, args: ['ngStyle.xl',] }],\n    ngStyleLtSm: [{ type: Input, args: ['ngStyle.lt-sm',] }],\n    ngStyleLtMd: [{ type: Input, args: ['ngStyle.lt-md',] }],\n    ngStyleLtLg: [{ type: Input, args: ['ngStyle.lt-lg',] }],\n    ngStyleLtXl: [{ type: Input, args: ['ngStyle.lt-xl',] }],\n    ngStyleGtXs: [{ type: Input, args: ['ngStyle.gt-xs',] }],\n    ngStyleGtSm: [{ type: Input, args: ['ngStyle.gt-sm',] }],\n    ngStyleGtMd: [{ type: Input, args: ['ngStyle.gt-md',] }],\n    ngStyleGtLg: [{ type: Input, args: ['ngStyle.gt-lg',] }]\n};\n/**\n * Build a styles map from a list of styles, while sanitizing bad values first\n * @param {?} styles\n * @param {?=} sanitize\n * @return {?}\n */\nfunction buildMapFromList$1(styles, sanitize) {\n    /** @type {?} */\n    const sanitizeValue = (it) => {\n        if (sanitize) {\n            it.value = sanitize(it.value);\n        }\n        return it;\n    };\n    return styles\n        .map(stringToKeyValue)\n        .filter(entry => !!entry)\n        .map(sanitizeValue)\n        .reduce(keyValuesToMap, /** @type {?} */ ({}));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst ALL_DIRECTIVES = [\n    ShowHideDirective,\n    ClassDirective,\n    StyleDirective,\n    ImgSrcDirective\n];\n/**\n * *****************************************************************\n * Define module for the Extended API\n * *****************************************************************\n */\nclass ExtendedModule {\n}\nExtendedModule.decorators = [\n    { type: NgModule, args: [{\n                imports: [CoreModule],\n                declarations: [...ALL_DIRECTIVES],\n                exports: [...ALL_DIRECTIVES]\n            },] },\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\nexport { ExtendedModule, ClassDirective, ImgSrcDirective, negativeOf, ShowHideDirective, StyleDirective };\n"]}