{"version":3,"sources":["/Users/abhishekkargawal/Documents/Nupur/policies-list/PolicyClient/node_modules/@angular/flex-layout/esm2015/core.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmXC,yIAGC;;;;;;;;;;;;kCAKkO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA+KnO,iHAGC;;;;;;;;;;;;;;;;;kCAOoO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAyNrO,uHAGC;;;;;;;;;;kGAMqO;;;;;;;;;;;;;;;;;;;;CAkBtO;;;;;;0BAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4DD,0HAGC;;;;;gDAC2L;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgmB5L;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiWA,yGAGC;;;;;;;;;;;;;;;;gEAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoSD,+GAGC;;;;;;;;;;;;;;;kCAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2GD,uHAGC;;;;;;;;;;kGAMqO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkStO,iHAGC;;;;;;;;;;;;;;;;;;;;;;;;;kCAQ4Q","file":"core.js","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { APP_BOOTSTRAP_LISTENER, PLATFORM_ID, InjectionToken, inject, Injectable, Inject, NgModule, NgZone, SimpleChange, Optional, defineInjectable } from '@angular/core';\nimport { DOCUMENT, isPlatformBrowser, isPlatformServer } from '@angular/common';\nimport { BehaviorSubject } from 'rxjs';\nimport { filter, map } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Find all of the server-generated stylings, if any, and remove them\n * This will be in the form of inline classes and the style block in the\n * head of the DOM\n * @param {?} _document\n * @param {?} platformId\n * @return {?}\n */\nfunction removeStyles(_document, platformId) {\n    return () => {\n        if (isPlatformBrowser(platformId)) {\n            /** @type {?} */\n            const elements = Array.from(_document.querySelectorAll(`[class*=${CLASS_NAME}]`));\n            /** @type {?} */\n            const classRegex = /\\bflex-layout-.+?\\b/g;\n            elements.forEach(el => {\n                el.classList.contains(`${CLASS_NAME}ssr`) && el.parentNode ?\n                    el.parentNode.removeChild(el) : el.className.replace(classRegex, '');\n            });\n        }\n    };\n}\n/** *\n *  Provider to remove SSR styles on the browser\n  @type {?} */\nconst BROWSER_PROVIDER = {\n    provide: /** @type {?} */ (APP_BOOTSTRAP_LISTENER),\n    useFactory: removeStyles,\n    deps: [DOCUMENT, PLATFORM_ID],\n    multi: true\n};\n/** @type {?} */\nconst CLASS_NAME = 'flex-layout-';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst BREAKPOINT = new InjectionToken('Flex Layout token, collect all breakpoints into one provider', {\n    providedIn: 'root',\n    factory: () => null\n});\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst RESPONSIVE_ALIASES = [\n    'xs', 'gt-xs', 'sm', 'gt-sm', 'md', 'gt-md', 'lg', 'gt-lg', 'xl'\n];\n/** @type {?} */\nconst DEFAULT_BREAKPOINTS = [\n    {\n        alias: 'xs',\n        mediaQuery: '(min-width: 0px) and (max-width: 599px)'\n    },\n    {\n        alias: 'gt-xs',\n        overlapping: true,\n        mediaQuery: '(min-width: 600px)'\n    },\n    {\n        alias: 'lt-sm',\n        overlapping: true,\n        mediaQuery: '(max-width: 599px)'\n    },\n    {\n        alias: 'sm',\n        mediaQuery: '(min-width: 600px) and (max-width: 959px)'\n    },\n    {\n        alias: 'gt-sm',\n        overlapping: true,\n        mediaQuery: '(min-width: 960px)'\n    },\n    {\n        alias: 'lt-md',\n        overlapping: true,\n        mediaQuery: '(max-width: 959px)'\n    },\n    {\n        alias: 'md',\n        mediaQuery: '(min-width: 960px) and (max-width: 1279px)'\n    },\n    {\n        alias: 'gt-md',\n        overlapping: true,\n        mediaQuery: '(min-width: 1280px)'\n    },\n    {\n        alias: 'lt-lg',\n        overlapping: true,\n        mediaQuery: '(max-width: 1279px)'\n    },\n    {\n        alias: 'lg',\n        mediaQuery: '(min-width: 1280px) and (max-width: 1919px)'\n    },\n    {\n        alias: 'gt-lg',\n        overlapping: true,\n        mediaQuery: '(min-width: 1920px)'\n    },\n    {\n        alias: 'lt-xl',\n        overlapping: true,\n        mediaQuery: '(max-width: 1919px)'\n    },\n    {\n        alias: 'xl',\n        mediaQuery: '(min-width: 1920px) and (max-width: 5000px)'\n    }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** @type {?} */\nconst HANDSET_PORTRAIT = '(orientation: portrait) and (max-width: 599px)';\n/** @type {?} */\nconst HANDSET_LANDSCAPE = '(orientation: landscape) and (max-width: 959px)';\n/** @type {?} */\nconst TABLET_LANDSCAPE = '(orientation: landscape) and (min-width: 960px) and (max-width: 1279px)';\n/** @type {?} */\nconst TABLET_PORTRAIT = '(orientation: portrait) and (min-width: 600px) and (max-width: 839px)';\n/** @type {?} */\nconst WEB_PORTRAIT = '(orientation: portrait) and (min-width: 840px)';\n/** @type {?} */\nconst WEB_LANDSCAPE = '(orientation: landscape) and (min-width: 1280px)';\n/** @type {?} */\nconst ScreenTypes = {\n    'HANDSET': `${HANDSET_PORTRAIT}, ${HANDSET_LANDSCAPE}`,\n    'TABLET': `${TABLET_PORTRAIT} , ${TABLET_LANDSCAPE}`,\n    'WEB': `${WEB_PORTRAIT}, ${WEB_LANDSCAPE} `,\n    'HANDSET_PORTRAIT': `${HANDSET_PORTRAIT}`,\n    'TABLET_PORTRAIT': `${TABLET_PORTRAIT} `,\n    'WEB_PORTRAIT': `${WEB_PORTRAIT}`,\n    'HANDSET_LANDSCAPE': `${HANDSET_LANDSCAPE}]`,\n    'TABLET_LANDSCAPE': `${TABLET_LANDSCAPE}`,\n    'WEB_LANDSCAPE': `${WEB_LANDSCAPE}`\n};\n/** *\n * Extended Breakpoints for handset/tablets with landscape or portrait orientations\n  @type {?} */\nconst ORIENTATION_BREAKPOINTS = [\n    { 'alias': 'handset', 'mediaQuery': ScreenTypes.HANDSET },\n    { 'alias': 'handset.landscape', 'mediaQuery': ScreenTypes.HANDSET_LANDSCAPE },\n    { 'alias': 'handset.portrait', 'mediaQuery': ScreenTypes.HANDSET_PORTRAIT },\n    { 'alias': 'tablet', 'mediaQuery': ScreenTypes.TABLET },\n    { 'alias': 'tablet.landscape', 'mediaQuery': ScreenTypes.TABLET },\n    { 'alias': 'tablet.portrait', 'mediaQuery': ScreenTypes.TABLET_PORTRAIT },\n    { 'alias': 'web', 'mediaQuery': ScreenTypes.WEB, overlapping: true },\n    { 'alias': 'web.landscape', 'mediaQuery': ScreenTypes.WEB_LANDSCAPE, overlapping: true },\n    { 'alias': 'web.portrait', 'mediaQuery': ScreenTypes.WEB_PORTRAIT, overlapping: true }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Extends an object with the *enumerable* and *own* properties of one or more source objects,\n * similar to Object.assign.\n *\n * @param {?} dest The object which will have properties copied to it.\n * @param {...?} sources The source objects from which properties will be copied.\n * @return {?}\n */\nfunction extendObject(dest, ...sources) {\n    if (dest == null) {\n        throw TypeError('Cannot convert undefined or null to object');\n    }\n    for (let source of sources) {\n        if (source != null) {\n            for (let key in source) {\n                if (source.hasOwnProperty(key)) {\n                    dest[key] = source[key];\n                }\n            }\n        }\n    }\n    return dest;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst ALIAS_DELIMITERS = /(\\.|-|_)/g;\n/**\n * @param {?} part\n * @return {?}\n */\nfunction firstUpperCase(part) {\n    /** @type {?} */\n    let first = part.length > 0 ? part.charAt(0) : '';\n    /** @type {?} */\n    let remainder = (part.length > 1) ? part.slice(1) : '';\n    return first.toUpperCase() + remainder;\n}\n/**\n * Converts snake-case to SnakeCase.\n * @param {?} name Text to UpperCamelCase\n * @return {?}\n */\nfunction camelCase(name) {\n    return name\n        .replace(ALIAS_DELIMITERS, '|')\n        .split('|')\n        .map(firstUpperCase)\n        .join('');\n}\n/**\n * For each breakpoint, ensure that a Suffix is defined;\n * fallback to UpperCamelCase the unique Alias value\n * @param {?} list\n * @return {?}\n */\nfunction validateSuffixes(list) {\n    list.forEach((bp) => {\n        if (!bp.suffix) {\n            bp.suffix = camelCase(bp.alias); // create Suffix value based on alias\n            bp.overlapping = !!bp.overlapping; // ensure default value\n        }\n    });\n    return list;\n}\n/**\n * Merge a custom breakpoint list with the default list based on unique alias values\n *  - Items are added if the alias is not in the default list\n *  - Items are merged with the custom override if the alias exists in the default list\n * @param {?} defaults\n * @param {?=} custom\n * @return {?}\n */\nfunction mergeByAlias(defaults, custom = []) {\n    /** @type {?} */\n    const dict = {};\n    defaults.forEach(bp => {\n        dict[bp.alias] = bp;\n    });\n    // Merge custom breakpoints\n    custom.forEach((bp) => {\n        if (dict[bp.alias]) {\n            extendObject(dict[bp.alias], bp);\n        }\n        else {\n            dict[bp.alias] = bp;\n        }\n    });\n    return validateSuffixes(Object.keys(dict).map(k => dict[k]));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst DEFAULT_CONFIG = {\n    addFlexToParent: true,\n    addOrientationBps: false,\n    disableDefaultBps: false,\n    disableVendorPrefixes: false,\n    serverLoaded: false,\n    useColumnBasisZero: true,\n};\n/** @type {?} */\nconst LAYOUT_CONFIG = new InjectionToken('Flex Layout token, config options for the library', {\n    providedIn: 'root',\n    factory: () => DEFAULT_CONFIG\n});\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n *  Injection token unique to the flex-layout library.\n *  Use this token when build a custom provider (see below).\n  @type {?} */\nconst BREAKPOINTS = new InjectionToken('Token (@angular/flex-layout) Breakpoints', {\n    providedIn: 'root',\n    factory: () => {\n        /** @type {?} */\n        const breakpoints = inject(BREAKPOINT);\n        /** @type {?} */\n        const layoutConfig = inject(LAYOUT_CONFIG);\n        /** @type {?} */\n        const bpFlattenArray = [].concat.apply([], (breakpoints || [])\n            .map((v) => Array.isArray(v) ? v : [v]));\n        /** @type {?} */\n        const builtIns = (layoutConfig.disableDefaultBps ? [] : DEFAULT_BREAKPOINTS)\n            .concat(layoutConfig.addOrientationBps ? ORIENTATION_BREAKPOINTS : []);\n        return mergeByAlias(builtIns, bpFlattenArray);\n    }\n});\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Registry of 1..n MediaQuery breakpoint ranges\n * This is published as a provider and may be overridden from custom, application-specific ranges\n *\n */\nclass BreakPointRegistry {\n    /**\n     * @param {?} _registry\n     */\n    constructor(_registry) {\n        this._registry = _registry;\n    }\n    /**\n     * Accessor to raw list\n     * @return {?}\n     */\n    get items() {\n        return [...this._registry];\n    }\n    /**\n     * Accessor to sorted list used for registration with matchMedia API\n     *\n     * NOTE: During breakpoint registration, we want to register the overlaps FIRST\n     *       so the non-overlaps will trigger the MatchMedia:BehaviorSubject last!\n     *       And the largest, non-overlap, matching breakpoint should be the lastReplay value\n     * @return {?}\n     */\n    get sortedItems() {\n        /** @type {?} */\n        let overlaps = this._registry.filter(it => it.overlapping === true);\n        /** @type {?} */\n        let nonOverlaps = this._registry.filter(it => it.overlapping !== true);\n        return [...overlaps, ...nonOverlaps];\n    }\n    /**\n     * Search breakpoints by alias (e.g. gt-xs)\n     * @param {?} alias\n     * @return {?}\n     */\n    findByAlias(alias) {\n        return this._registry.find(bp => bp.alias == alias) || null;\n    }\n    /**\n     * @param {?} query\n     * @return {?}\n     */\n    findByQuery(query) {\n        return this._registry.find(bp => bp.mediaQuery == query) || null;\n    }\n    /**\n     * Get all the breakpoints whose ranges could overlapping `normal` ranges;\n     * e.g. gt-sm overlaps md, lg, and xl\n     * @return {?}\n     */\n    get overlappings() {\n        return this._registry.filter(it => it.overlapping == true);\n    }\n    /**\n     * Get list of all registered (non-empty) breakpoint aliases\n     * @return {?}\n     */\n    get aliases() {\n        return this._registry.map(it => it.alias);\n    }\n    /**\n     * Aliases are mapped to properties using suffixes\n     * e.g.  'gt-sm' for property 'layout'  uses suffix 'GtSm'\n     * for property layoutGtSM.\n     * @return {?}\n     */\n    get suffixes() {\n        return this._registry.map(it => !!it.suffix ? it.suffix : '');\n    }\n}\nBreakPointRegistry.decorators = [\n    { type: Injectable, args: [{ providedIn: 'root' },] },\n];\n/** @nocollapse */\nBreakPointRegistry.ctorParameters = () => [\n    { type: Array, decorators: [{ type: Inject, args: [BREAKPOINTS,] }] }\n];\n/** @nocollapse */ BreakPointRegistry.ngInjectableDef = defineInjectable({ factory: function BreakPointRegistry_Factory() { return new BreakPointRegistry(inject(BREAKPOINTS)); }, token: BreakPointRegistry, providedIn: \"root\" });\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Class instances emitted [to observers] for each mql notification\n */\nclass MediaChange {\n    /**\n     * @param {?=} matches\n     * @param {?=} mediaQuery\n     * @param {?=} mqAlias\n     * @param {?=} suffix\n     */\n    constructor(matches = false, mediaQuery = 'all', mqAlias = '', suffix = '' // e.g.   GtSM, Md, GtLg\n    ) {\n        this.matches = matches;\n        this.mediaQuery = mediaQuery;\n        this.mqAlias = mqAlias;\n        this.suffix = suffix;\n        this.property = '';\n    }\n    /**\n     * @return {?}\n     */\n    clone() {\n        return new MediaChange(this.matches, this.mediaQuery, this.mqAlias, this.suffix);\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * MediaMonitor configures listeners to mediaQuery changes and publishes an Observable facade to\n * convert mediaQuery change callbacks to subscriber notifications. These notifications will be\n * performed within the ng Zone to trigger change detections and component updates.\n *\n * NOTE: both mediaQuery activations and de-activations are announced in notifications\n */\nclass MatchMedia {\n    /**\n     * @param {?} _zone\n     * @param {?} _platformId\n     * @param {?} _document\n     */\n    constructor(_zone, _platformId, _document) {\n        this._zone = _zone;\n        this._platformId = _platformId;\n        this._document = _document;\n        this._registry = new Map();\n        this._source = new BehaviorSubject(new MediaChange(true));\n        this._observable$ = this._source.asObservable();\n    }\n    /**\n     * For the specified mediaQuery?\n     * @param {?} mediaQuery\n     * @return {?}\n     */\n    isActive(mediaQuery) {\n        /** @type {?} */\n        let mql = this._registry.get(mediaQuery);\n        return !!mql ? mql.matches : false;\n    }\n    /**\n     * External observers can watch for all (or a specific) mql changes.\n     * Typically used by the MediaQueryAdaptor; optionally available to components\n     * who wish to use the MediaMonitor as mediaMonitor$ observable service.\n     *\n     * NOTE: if a mediaQuery is not specified, then ALL mediaQuery activations will\n     *       be announced.\n     * @param {?=} mediaQuery\n     * @return {?}\n     */\n    observe(mediaQuery) {\n        if (mediaQuery) {\n            this.registerQuery(mediaQuery);\n        }\n        return this._observable$.pipe(filter((change) => {\n            return mediaQuery ? (change.mediaQuery === mediaQuery) : true;\n        }));\n    }\n    /**\n     * Based on the BreakPointRegistry provider, register internal listeners for each unique\n     * mediaQuery. Each listener emits specific MediaChange data to observers\n     * @param {?} mediaQuery\n     * @return {?}\n     */\n    registerQuery(mediaQuery) {\n        /** @type {?} */\n        let list = normalizeQuery(mediaQuery);\n        if (list.length > 0) {\n            this._prepareQueryCSS(list, this._document);\n            list.forEach(query => {\n                /** @type {?} */\n                let mql = this._registry.get(query);\n                /** @type {?} */\n                let onMQLEvent = (e) => {\n                    this._zone.run(() => {\n                        /** @type {?} */\n                        let change = new MediaChange(e.matches, query);\n                        this._source.next(change);\n                    });\n                };\n                if (!mql) {\n                    mql = this._buildMQL(query);\n                    mql.addListener(onMQLEvent);\n                    this._registry.set(query, mql);\n                }\n                if (mql.matches) {\n                    onMQLEvent(/** @type {?} */ ((mql)));\n                }\n            });\n        }\n    }\n    /**\n     * Call window.matchMedia() to build a MediaQueryList; which\n     * supports 0..n listeners for activation/deactivation\n     * @param {?} query\n     * @return {?}\n     */\n    _buildMQL(query) {\n        /** @type {?} */\n        let canListen = isPlatformBrowser(this._platformId) &&\n            !!(/** @type {?} */ (window)).matchMedia('all').addListener;\n        return canListen ? (/** @type {?} */ (window)).matchMedia(query) : /** @type {?} */ (({\n            matches: query === 'all' || query === '',\n            media: query,\n            addListener: () => {\n            },\n            removeListener: () => {\n            }\n        }));\n    }\n    /**\n     * For Webkit engines that only trigger the MediaQueryList Listener\n     * when there is at least one CSS selector for the respective media query.\n     *\n     * @param {?} mediaQueries\n     * @param {?} _document\n     * @return {?}\n     */\n    _prepareQueryCSS(mediaQueries, _document) {\n        /** @type {?} */\n        const list = mediaQueries.filter(it => !ALL_STYLES[it]);\n        if (list.length > 0) {\n            /** @type {?} */\n            const query = list.join(', ');\n            try {\n                /** @type {?} */\n                let styleEl = _document.createElement('style');\n                styleEl.setAttribute('type', 'text/css');\n                if (!(/** @type {?} */ (styleEl)).styleSheet) {\n                    /** @type {?} */\n                    let cssText = `\n/*\n  @angular/flex-layout - workaround for possible browser quirk with mediaQuery listeners\n  see http://bit.ly/2sd4HMP\n*/\n@media ${query} {.fx-query-test{ }}\n`;\n                    styleEl.appendChild(_document.createTextNode(cssText));\n                } /** @type {?} */\n                ((_document.head)).appendChild(styleEl);\n                // Store in private global registry\n                list.forEach(mq => ALL_STYLES[mq] = styleEl);\n            }\n            catch (e) {\n                console.error(e);\n            }\n        }\n    }\n}\nMatchMedia.decorators = [\n    { type: Injectable, args: [{ providedIn: 'root' },] },\n];\n/** @nocollapse */\nMatchMedia.ctorParameters = () => [\n    { type: NgZone },\n    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\n/** @nocollapse */ MatchMedia.ngInjectableDef = defineInjectable({ factory: function MatchMedia_Factory() { return new MatchMedia(inject(NgZone), inject(PLATFORM_ID), inject(DOCUMENT)); }, token: MatchMedia, providedIn: \"root\" });\n/** *\n * Private global registry for all dynamically-created, injected style tags\n * @see prepare(query)\n  @type {?} */\nconst ALL_STYLES = {};\n/**\n * Always convert to unique list of queries; for iteration in ::registerQuery()\n * @param {?} mediaQuery\n * @return {?}\n */\nfunction normalizeQuery(mediaQuery) {\n    return (typeof mediaQuery === 'undefined') ? [] :\n        (typeof mediaQuery === 'string') ? [mediaQuery] : unique(/** @type {?} */ (mediaQuery));\n}\n/**\n * Filter duplicate mediaQueries in the list\n * @param {?} list\n * @return {?}\n */\nfunction unique(list) {\n    /** @type {?} */\n    let seen = {};\n    return list.filter(item => {\n        return seen.hasOwnProperty(item) ? false : (seen[item] = true);\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * For the specified MediaChange, make sure it contains the breakpoint alias\n * and suffix (if available).\n * @param {?} dest\n * @param {?} source\n * @return {?}\n */\nfunction mergeAlias(dest, source) {\n    return extendObject(dest, source ? {\n        mqAlias: source.alias,\n        suffix: source.suffix\n    } : {});\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Base class for MediaService and pseudo-token for\n * @abstract\n */\nclass ObservableMedia {\n}\n/**\n * Class internalizes a MatchMedia service and exposes an Subscribable and Observable interface.\n * This an Observable with that exposes a feature to subscribe to mediaQuery\n * changes and a validator method (`isActive(<alias>)`) to test if a mediaQuery (or alias) is\n * currently active.\n *\n * !! Only mediaChange activations (not de-activations) are announced by the ObservableMedia\n *\n * This class uses the BreakPoint Registry to inject alias information into the raw MediaChange\n * notification. For custom mediaQuery notifications, alias information will not be injected and\n * those fields will be ''.\n *\n * !! This is not an actual Observable. It is a wrapper of an Observable used to publish additional\n * methods like `isActive(<alias>). To access the Observable and use RxJS operators, use\n * `.asObservable()` with syntax like media.asObservable().map(....).\n *\n * \\@usage\n *\n *  // RxJS\n *  import {filter} from 'rxjs/operators/filter';\n *  import { ObservableMedia } from '\\@angular/flex-layout';\n *\n * \\@Component({ ... })\n *  export class AppComponent {\n *    status : string = '';\n *\n *    constructor(  media:ObservableMedia ) {\n *      let onChange = (change:MediaChange) => {\n *        this.status = change ? `'${change.mqAlias}' = (${change.mediaQuery})` : '';\n *      };\n *\n *      // Subscribe directly or access observable to use filter/map operators\n *      // e.g.\n *      //      media.subscribe(onChange);\n *\n *      media.asObservable()\n *        .pipe(\n *          filter((change:MediaChange) => true)   // silly noop filter\n *        ).subscribe(onChange);\n *    }\n *  }\n */\nclass MediaService {\n    /**\n     * @param {?} breakpoints\n     * @param {?} mediaWatcher\n     */\n    constructor(breakpoints, mediaWatcher) {\n        this.breakpoints = breakpoints;\n        this.mediaWatcher = mediaWatcher;\n        /**\n         * Should we announce gt-<xxx> breakpoint activations ?\n         */\n        this.filterOverlaps = true;\n        this._registerBreakPoints();\n        this.observable$ = this._buildObservable();\n    }\n    /**\n     * Test if specified query/alias is active.\n     * @param {?} alias\n     * @return {?}\n     */\n    isActive(alias) {\n        /** @type {?} */\n        let query = this._toMediaQuery(alias);\n        return this.mediaWatcher.isActive(query);\n    }\n    /**\n     * Proxy to the Observable subscribe method\n     * @param {?=} observerOrNext\n     * @param {?=} error\n     * @param {?=} complete\n     * @return {?}\n     */\n    subscribe(observerOrNext, error, complete) {\n        if (observerOrNext) {\n            if (typeof observerOrNext === 'object') {\n                return this.observable$.subscribe(observerOrNext.next, observerOrNext.error, observerOrNext.complete);\n            }\n        }\n        return this.observable$.subscribe(observerOrNext, error, complete);\n    }\n    /**\n     * Access to observable for use with operators like\n     * .filter(), .map(), etc.\n     * @return {?}\n     */\n    asObservable() {\n        return this.observable$;\n    }\n    /**\n     * Register all the mediaQueries registered in the BreakPointRegistry\n     * This is needed so subscribers can be auto-notified of all standard, registered\n     * mediaQuery activations\n     * @return {?}\n     */\n    _registerBreakPoints() {\n        /** @type {?} */\n        let queries = this.breakpoints.sortedItems.map(bp => bp.mediaQuery);\n        this.mediaWatcher.registerQuery(queries);\n    }\n    /**\n     * Prepare internal observable\n     *\n     * NOTE: the raw MediaChange events [from MatchMedia] do not\n     *       contain important alias information; as such this info\n     *       must be injected into the MediaChange\n     * @return {?}\n     */\n    _buildObservable() {\n        /** @type {?} */\n        const self = this;\n        /** @type {?} */\n        const media$ = this.mediaWatcher.observe();\n        /** @type {?} */\n        const activationsOnly = (change) => {\n            return change.matches === true;\n        };\n        /** @type {?} */\n        const addAliasInformation = (change) => {\n            return mergeAlias(change, this._findByQuery(change.mediaQuery));\n        };\n        /** @type {?} */\n        const excludeOverlaps = (change) => {\n            /** @type {?} */\n            let bp = this.breakpoints.findByQuery(change.mediaQuery);\n            return !bp ? true : !(self.filterOverlaps && bp.overlapping);\n        };\n        /**\n             * Only pass/announce activations (not de-activations)\n             * Inject associated (if any) alias information into the MediaChange event\n             * Exclude mediaQuery activations for overlapping mQs. List bounded mQ ranges only\n             */\n        return media$.pipe(filter(activationsOnly), filter(excludeOverlaps), map(addAliasInformation));\n    }\n    /**\n     * Breakpoint locator by alias\n     * @param {?} alias\n     * @return {?}\n     */\n    _findByAlias(alias) {\n        return this.breakpoints.findByAlias(alias);\n    }\n    /**\n     * Breakpoint locator by mediaQuery\n     * @param {?} query\n     * @return {?}\n     */\n    _findByQuery(query) {\n        return this.breakpoints.findByQuery(query);\n    }\n    /**\n     * Find associated breakpoint (if any)\n     * @param {?} query\n     * @return {?}\n     */\n    _toMediaQuery(query) {\n        /** @type {?} */\n        let bp = this._findByAlias(query) || this._findByQuery(query);\n        return bp ? bp.mediaQuery : query;\n    }\n}\nMediaService.decorators = [\n    { type: Injectable, args: [{ providedIn: 'root' },] },\n];\n/** @nocollapse */\nMediaService.ctorParameters = () => [\n    { type: BreakPointRegistry },\n    { type: MatchMedia }\n];\n/** @nocollapse */ MediaService.ngInjectableDef = defineInjectable({ factory: function MediaService_Factory() { return new MediaService(inject(BreakPointRegistry), inject(MatchMedia)); }, token: MediaService, providedIn: \"root\" });\n/** @type {?} */\nconst ObservableMediaProvider = {\n    // tslint:disable-line:variable-name\n    provide: ObservableMedia,\n    useClass: MediaService\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * *****************************************************************\n * Define module for the MediaQuery API\n * *****************************************************************\n */\nclass CoreModule {\n}\nCoreModule.decorators = [\n    { type: NgModule, args: [{\n                providers: [ObservableMediaProvider, BROWSER_PROVIDER]\n            },] },\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Utility to emulate a CSS stylesheet\n *\n * This utility class stores all of the styles for a given HTML element\n * as a readonly `stylesheet` map.\n */\nclass StylesheetMap {\n    constructor() {\n        this.stylesheet = new Map();\n    }\n    /**\n     * Add an individual style to an HTML element\n     * @param {?} element\n     * @param {?} style\n     * @param {?} value\n     * @return {?}\n     */\n    addStyleToElement(element, style, value) {\n        /** @type {?} */\n        const stylesheet = this.stylesheet.get(element);\n        if (stylesheet) {\n            stylesheet.set(style, value);\n        }\n        else {\n            this.stylesheet.set(element, new Map([[style, value]]));\n        }\n    }\n    /**\n     * Clear the virtual stylesheet\n     * @return {?}\n     */\n    clearStyles() {\n        this.stylesheet.clear();\n    }\n    /**\n     * Retrieve a given style for an HTML element\n     * @param {?} el\n     * @param {?} styleName\n     * @return {?}\n     */\n    getStyleForElement(el, styleName) {\n        /** @type {?} */\n        const styles = this.stylesheet.get(el);\n        /** @type {?} */\n        let value = '';\n        if (styles) {\n            /** @type {?} */\n            const style = styles.get(styleName);\n            if (typeof style === 'number' || typeof style === 'string') {\n                value = style + '';\n            }\n        }\n        return value;\n    }\n}\nStylesheetMap.decorators = [\n    { type: Injectable, args: [{ providedIn: 'root' },] },\n];\n/** @nocollapse */ StylesheetMap.ngInjectableDef = defineInjectable({ factory: function StylesheetMap_Factory() { return new StylesheetMap(); }, token: StylesheetMap, providedIn: \"root\" });\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n * Token that is provided to tell whether the FlexLayoutServerModule\n * has been included in the bundle\n *\n * NOTE: This can be manually provided to disable styles when using SSR\n  @type {?} */\nconst SERVER_TOKEN = new InjectionToken('FlexLayoutServerLoaded', {\n    providedIn: 'root',\n    factory: () => false\n});\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n  @type {?} */\nconst INLINE = 'inline';\n/** @type {?} */\nconst LAYOUT_VALUES = ['row', 'column', 'row-reverse', 'column-reverse'];\n/**\n * Validate the direction|'direction wrap' value and then update the host's inline flexbox styles\n * @param {?} value\n * @return {?}\n */\nfunction buildLayoutCSS(value) {\n    let [direction, wrap, isInline] = validateValue(value);\n    return buildCSS(direction, wrap, isInline);\n}\n/**\n * Validate the value to be one of the acceptable value options\n * Use default fallback of 'row'\n * @param {?} value\n * @return {?}\n */\nfunction validateValue(value) {\n    value = value ? value.toLowerCase() : '';\n    let [direction, wrap, inline] = value.split(' ');\n    // First value must be the `flex-direction`\n    if (!LAYOUT_VALUES.find(x => x === direction)) {\n        direction = LAYOUT_VALUES[0];\n    }\n    if (wrap === INLINE) {\n        wrap = (inline !== INLINE) ? inline : '';\n        inline = INLINE;\n    }\n    return [direction, validateWrapValue(wrap), !!inline];\n}\n/**\n * Convert layout-wrap='<value>' to expected flex-wrap style\n * @param {?} value\n * @return {?}\n */\nfunction validateWrapValue(value) {\n    if (!!value) {\n        switch (value.toLowerCase()) {\n            case 'reverse':\n            case 'wrap-reverse':\n            case 'reverse-wrap':\n                value = 'wrap-reverse';\n                break;\n            case 'no':\n            case 'none':\n            case 'nowrap':\n                value = 'nowrap';\n                break;\n            // All other values fallback to 'wrap'\n            default:\n                value = 'wrap';\n                break;\n        }\n    }\n    return value;\n}\n/**\n * Build the CSS that should be assigned to the element instance\n * BUG:\n *   1) min-height on a column flex container wonâ€™t apply to its flex item children in IE 10-11.\n *      Use height instead if possible; height : <xxx>vh;\n *\n *  This way any padding or border specified on the child elements are\n *  laid out and drawn inside that element's specified width and height.\n * @param {?} direction\n * @param {?=} wrap\n * @param {?=} inline\n * @return {?}\n */\nfunction buildCSS(direction, wrap = null, inline = false) {\n    return {\n        'display': inline ? 'inline-flex' : 'flex',\n        'box-sizing': 'border-box',\n        'flex-direction': direction,\n        'flex-wrap': !!wrap ? wrap : null\n    };\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nclass KeyOptions {\n    /**\n     * @param {?} baseKey\n     * @param {?} defaultValue\n     * @param {?} inputKeys\n     */\n    constructor(baseKey, defaultValue, inputKeys) {\n        this.baseKey = baseKey;\n        this.defaultValue = defaultValue;\n        this.inputKeys = inputKeys;\n    }\n}\n/**\n * ResponsiveActivation acts as a proxy between the MonitorMedia service (which emits mediaQuery\n * changes) and the fx API directives. The MQA proxies mediaQuery change events and notifies the\n * directive via the specified callback.\n *\n * - The MQA also determines which directive property should be used to determine the\n *   current change 'value'... BEFORE the original `onMediaQueryChanges()` method is called.\n * - The `ngOnDestroy()` method is also head-hooked to enable auto-unsubscribe from the\n *   MediaQueryServices.\n *\n * NOTE: these interceptions enables the logic in the fx API directives to remain terse and clean.\n */\nclass ResponsiveActivation {\n    /**\n     * Constructor\n     * @param {?} _options\n     * @param {?} _mediaMonitor\n     * @param {?} _onMediaChanges\n     */\n    constructor(_options, _mediaMonitor, _onMediaChanges) {\n        this._options = _options;\n        this._mediaMonitor = _mediaMonitor;\n        this._onMediaChanges = _onMediaChanges;\n        this._subscribers = [];\n        this._activatedInputKey = '';\n        this._registryMap = this._buildRegistryMap();\n        this._subscribers = this._configureChangeObservers();\n    }\n    /**\n     * Get a readonly sorted list of the breakpoints corresponding to the directive properties\n     * defined in the HTML markup: the sorting is done from largest to smallest. The order is\n     * important when several media queries are 'registered' and from which, the browser uses the\n     * first matching media query.\n     * @return {?}\n     */\n    get registryFromLargest() {\n        return [...this._registryMap].reverse();\n    }\n    /**\n     * Accessor to the DI'ed directive property\n     * Each directive instance has a reference to the MediaMonitor which is\n     * used HERE to subscribe to mediaQuery change notifications.\n     * @return {?}\n     */\n    get mediaMonitor() {\n        return this._mediaMonitor;\n    }\n    /**\n     * Determine which directive \\@Input() property is currently active (for the viewport size):\n     * The key must be defined (in use) or fallback to the 'closest' overlapping property key\n     * that is defined; otherwise the default property key will be used.\n     * e.g.\n     *      if `<div fxHide fxHide.gt-sm=\"false\">` is used but the current activated mediaQuery alias\n     *      key is `.md` then `.gt-sm` should be used instead\n     * @return {?}\n     */\n    get activatedInputKey() {\n        return this._activatedInputKey || this._options.baseKey;\n    }\n    /**\n     * Get the currently activated \\@Input value or the fallback default \\@Input value\n     * @return {?}\n     */\n    get activatedInput() {\n        /** @type {?} */\n        let key = this.activatedInputKey;\n        return this.hasKeyValue(key) ? this._lookupKeyValue(key) : this._options.defaultValue;\n    }\n    /**\n     * Fast validator for presence of attribute on the host element\n     * @param {?} key\n     * @return {?}\n     */\n    hasKeyValue(key) {\n        /** @type {?} */\n        let value = this._options.inputKeys[key];\n        return typeof value !== 'undefined';\n    }\n    /**\n     * Remove interceptors, restore original functions, and forward the onDestroy() call\n     * @return {?}\n     */\n    destroy() {\n        this._subscribers.forEach((link) => {\n            link.unsubscribe();\n        });\n        this._subscribers = [];\n    }\n    /**\n     * For each *defined* API property, register a callback to `_onMonitorEvents( )`\n     * Cache 1..n subscriptions for internal auto-unsubscribes when the the directive destructs\n     * @return {?}\n     */\n    _configureChangeObservers() {\n        /** @type {?} */\n        let subscriptions = [];\n        this._registryMap.forEach((bp) => {\n            if (this._keyInUse(bp.key)) {\n                /** @type {?} */\n                let buildChanges = (change) => {\n                    change = change.clone();\n                    change.property = this._options.baseKey;\n                    return change;\n                };\n                subscriptions.push(this.mediaMonitor\n                    .observe(bp.alias)\n                    .pipe(map(buildChanges))\n                    .subscribe(change => {\n                    this._onMonitorEvents(change);\n                }));\n            }\n        });\n        return subscriptions;\n    }\n    /**\n     * Build mediaQuery key-hashmap; only for the directive properties that are actually defined/used\n     * in the HTML markup\n     * @return {?}\n     */\n    _buildRegistryMap() {\n        return this.mediaMonitor.breakpoints\n            .map(bp => {\n            return /** @type {?} */ (extendObject({}, bp, {\n                baseKey: this._options.baseKey,\n                // e.g. layout, hide, self-align, flex-wrap\n                key: this._options.baseKey + bp.suffix // e.g.  layoutGtSm, layoutMd, layoutGtLg\n            }));\n        })\n            .filter(bp => this._keyInUse(bp.key));\n    }\n    /**\n     * Synchronizes change notifications with the current mq-activated \\@Input and calculates the\n     * mq-activated input value or the default value\n     * @param {?} change\n     * @return {?}\n     */\n    _onMonitorEvents(change) {\n        if (change.property == this._options.baseKey) {\n            change.value = this._calculateActivatedValue(change);\n            this._onMediaChanges(change);\n        }\n    }\n    /**\n     * Has the key been specified in the HTML markup and thus is intended\n     * to participate in activation processes.\n     * @param {?} key\n     * @return {?}\n     */\n    _keyInUse(key) {\n        return this._lookupKeyValue(key) !== undefined;\n    }\n    /**\n     *  Map input key associated with mediaQuery activation to closest defined input key\n     *  then return the values associated with the targeted input property\n     *\n     *  !! change events may arrive out-of-order (activate before deactivate)\n     *     so make sure the deactivate is used ONLY when the keys match\n     *     (since a different activate may be in use)\n     * @param {?} current\n     * @return {?}\n     */\n    _calculateActivatedValue(current) {\n        /** @type {?} */\n        const currentKey = this._options.baseKey + current.suffix;\n        /** @type {?} */\n        let newKey = this._activatedInputKey; // e.g. newKey == hideGtSm\n        newKey = current.matches ? currentKey : ((newKey == currentKey) ? '' : newKey);\n        this._activatedInputKey = this._validateInputKey(newKey);\n        return this.activatedInput;\n    }\n    /**\n     * For the specified input property key, validate it is defined (used in the markup)\n     * If not see if a overlapping mediaQuery-related input key fallback has been defined\n     *\n     * NOTE: scans in the order defined by activeOverLaps (largest viewport ranges -> smallest ranges)\n     * @param {?} inputKey\n     * @return {?}\n     */\n    _validateInputKey(inputKey) {\n        /** @type {?} */\n        let isMissingKey = (key) => !this._keyInUse(key);\n        if (isMissingKey(inputKey)) {\n            this.mediaMonitor.activeOverlaps.some(bp => {\n                /** @type {?} */\n                let key = this._options.baseKey + bp.suffix;\n                if (!isMissingKey(key)) {\n                    inputKey = key;\n                    return true; // exit .some()\n                }\n                return false;\n            });\n        }\n        return inputKey;\n    }\n    /**\n     * Get the value (if any) for the directive instances \\@Input property (aka key)\n     * @param {?} key\n     * @return {?}\n     */\n    _lookupKeyValue(key) {\n        return this._options.inputKeys[key];\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Abstract base class for the Layout API styling directives.\n * @abstract\n */\nclass BaseDirective {\n    /**\n     * @param {?} _mediaMonitor\n     * @param {?} _elementRef\n     * @param {?} _styler\n     */\n    constructor(_mediaMonitor, _elementRef, _styler) {\n        this._mediaMonitor = _mediaMonitor;\n        this._elementRef = _elementRef;\n        this._styler = _styler;\n        /**\n         * Dictionary of input keys with associated values\n         */\n        this._inputMap = {};\n        /**\n         * Has the `ngOnInit()` method fired\n         *\n         * Used to allow *ngFor tasks to finish and support queries like\n         * getComputedStyle() during ngOnInit().\n         */\n        this._hasInitialized = false;\n    }\n    /**\n     * @return {?}\n     */\n    get hasMediaQueryListener() {\n        return !!this._mqActivation;\n    }\n    /**\n     * Imperatively determine the current activated [input] value;\n     * if called before ngOnInit() this will return `undefined`\n     * @return {?}\n     */\n    get activatedValue() {\n        return this._mqActivation ? this._mqActivation.activatedInput : undefined;\n    }\n    /**\n     * Change the currently activated input value and force-update\n     * the injected CSS (by-passing change detection).\n     *\n     * NOTE: Only the currently activated input value will be modified;\n     *       other input values will NOT be affected.\n     * @param {?} value\n     * @return {?}\n     */\n    set activatedValue(value) {\n        /** @type {?} */\n        let key = 'baseKey';\n        /** @type {?} */\n        let previousVal;\n        if (this._mqActivation) {\n            key = this._mqActivation.activatedInputKey;\n            previousVal = this._inputMap[key];\n            this._inputMap[key] = value;\n        }\n        /** @type {?} */\n        let change = new SimpleChange(previousVal, value, false);\n        this.ngOnChanges(/** @type {?} */ ({ [key]: change }));\n    }\n    /**\n     * Does this directive have 1 or more responsive keys defined\n     * Note: we exclude the 'baseKey' key (which is NOT considered responsive)\n     * @param {?} baseKey\n     * @return {?}\n     */\n    hasResponsiveAPI(baseKey) {\n        /** @type {?} */\n        const totalKeys = Object.keys(this._inputMap).length;\n        /** @type {?} */\n        const baseValue = this._inputMap[baseKey];\n        return (totalKeys - (!!baseValue ? 1 : 0)) > 0;\n    }\n    /**\n     * Use post-component-initialization event to perform extra\n     * querying such as computed Display style\n     * @return {?}\n     */\n    ngOnInit() {\n        this._hasInitialized = true;\n    }\n    /**\n     * @param {?} change\n     * @return {?}\n     */\n    ngOnChanges(change) {\n        throw new Error(`BaseDirective::ngOnChanges should be overridden in subclass: ${change}`);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        if (this._mqActivation) {\n            this._mqActivation.destroy();\n        }\n        delete this._mediaMonitor;\n    }\n    /**\n     * Access to host element's parent DOM node\n     * @return {?}\n     */\n    get parentElement() {\n        return this._elementRef.nativeElement.parentNode;\n    }\n    /**\n     * @return {?}\n     */\n    get nativeElement() {\n        return this._elementRef.nativeElement;\n    }\n    /**\n     * Access the current value (if any) of the \\@Input property\n     * @param {?} key\n     * @return {?}\n     */\n    _queryInput(key) {\n        return this._inputMap[key];\n    }\n    /**\n     * Was the directive's default selector used ?\n     * If not, use the fallback value!\n     * @param {?} key\n     * @param {?} fallbackVal\n     * @return {?}\n     */\n    _getDefaultVal(key, fallbackVal) {\n        /** @type {?} */\n        let val = this._queryInput(key);\n        /** @type {?} */\n        let hasDefaultVal = (val !== undefined && val !== null);\n        return (hasDefaultVal && val !== '') ? val : fallbackVal;\n    }\n    /**\n     * Quick accessor to the current HTMLElement's `display` style\n     * Note: this allows us to preserve the original style\n     * and optional restore it when the mediaQueries deactivate\n     * @param {?=} source\n     * @return {?}\n     */\n    _getDisplayStyle(source = this.nativeElement) {\n        /** @type {?} */\n        const query = 'display';\n        return this._styler.lookupStyle(source, query);\n    }\n    /**\n     * Quick accessor to raw attribute value on the target DOM element\n     * @param {?} attribute\n     * @param {?=} source\n     * @return {?}\n     */\n    _getAttributeValue(attribute, source = this.nativeElement) {\n        return this._styler.lookupAttributeValue(source, attribute);\n    }\n    /**\n     * Determine the DOM element's Flexbox flow (flex-direction).\n     *\n     * Check inline style first then check computed (stylesheet) style.\n     * And optionally add the flow value to element's inline style.\n     * @param {?} target\n     * @param {?=} addIfMissing\n     * @return {?}\n     */\n    _getFlexFlowDirection(target, addIfMissing = false) {\n        /** @type {?} */\n        let value = 'row';\n        /** @type {?} */\n        let hasInlineValue = '';\n        if (target) {\n            [value, hasInlineValue] = this._styler.getFlowDirection(target);\n            if (!hasInlineValue && addIfMissing) {\n                /** @type {?} */\n                const style = buildLayoutCSS(value);\n                /** @type {?} */\n                const elements = [target];\n                this._styler.applyStyleToElements(style, elements);\n            }\n        }\n        return value.trim() || 'row';\n    }\n    /**\n     * Applies styles given via string pair or object map to the directive element\n     * @param {?} style\n     * @param {?=} value\n     * @param {?=} element\n     * @return {?}\n     */\n    _applyStyleToElement(style, value, element = this.nativeElement) {\n        this._styler.applyStyleToElement(element, style, value);\n    }\n    /**\n     * Applies styles given via string pair or object map to the directive's element\n     * @param {?} style\n     * @param {?} elements\n     * @return {?}\n     */\n    _applyStyleToElements(style, elements) {\n        this._styler.applyStyleToElements(style, elements);\n    }\n    /**\n     *  Save the property value; which may be a complex object.\n     *  Complex objects support property chains\n     * @param {?=} key\n     * @param {?=} source\n     * @return {?}\n     */\n    _cacheInput(key, source) {\n        if (typeof source === 'object') {\n            for (let prop in source) {\n                this._inputMap[prop] = source[prop];\n            }\n        }\n        else {\n            if (!!key) {\n                this._inputMap[key] = source;\n            }\n        }\n    }\n    /**\n     *  Build a ResponsiveActivation object used to manage subscriptions to mediaChange notifications\n     *  and intelligent lookup of the directive's property value that corresponds to that mediaQuery\n     *  (or closest match).\n     * @param {?} key\n     * @param {?} defaultValue\n     * @param {?} onMediaQueryChange\n     * @return {?}\n     */\n    _listenForMediaQueryChanges(key, defaultValue, onMediaQueryChange) {\n        // tslint:disable-line:max-line-length\n        if (!this._mqActivation) {\n            /** @type {?} */\n            let keyOptions = new KeyOptions(key, defaultValue, this._inputMap);\n            this._mqActivation = new ResponsiveActivation(keyOptions, this._mediaMonitor, (change) => onMediaQueryChange(change));\n        }\n        return this._mqActivation;\n    }\n    /**\n     * Special accessor to query for all child 'element' nodes regardless of type, class, etc\n     * @return {?}\n     */\n    get childrenNodes() {\n        /** @type {?} */\n        const obj = this.nativeElement.children;\n        /** @type {?} */\n        const buffer = [];\n        // iterate backwards ensuring that length is an UInt32\n        for (let i = obj.length; i--;) {\n            buffer[i] = obj[i];\n        }\n        return buffer;\n    }\n    /**\n     * Fast validator for presence of attribute on the host element\n     * @param {?} key\n     * @return {?}\n     */\n    hasKeyValue(key) {\n        return /** @type {?} */ ((this._mqActivation)).hasKeyValue(key);\n    }\n    /**\n     * @return {?}\n     */\n    get hasInitialized() {\n        return this._hasInitialized;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Adapter to the BaseDirective abstract class so it can be used via composition.\n * @see BaseDirective\n */\nclass BaseDirectiveAdapter extends BaseDirective {\n    /**\n     * BaseDirectiveAdapter constructor\n     * @param {?} _baseKey\n     * @param {?} _mediaMonitor\n     * @param {?} _elementRef\n     * @param {?} _styler\n     */\n    constructor(_baseKey, // non-responsive @Input property name\n    // non-responsive @Input property name\n    _mediaMonitor, _elementRef, _styler) {\n        super(_mediaMonitor, _elementRef, _styler);\n        this._baseKey = _baseKey;\n        this._mediaMonitor = _mediaMonitor;\n        this._elementRef = _elementRef;\n        this._styler = _styler;\n    }\n    /**\n     * Accessor to determine which \\@Input property is \"active\"\n     * e.g. which property value will be used.\n     * @return {?}\n     */\n    get activeKey() {\n        /** @type {?} */\n        let mqa = this._mqActivation;\n        /** @type {?} */\n        let key = mqa ? mqa.activatedInputKey : this._baseKey;\n        // Note: ClassDirective::SimpleChanges uses 'klazz' instead of 'class' as a key\n        return (key === 'class') ? 'klazz' : key;\n    }\n    /**\n     * Hash map of all \\@Input keys/values defined/used\n     * @return {?}\n     */\n    get inputMap() {\n        return this._inputMap;\n    }\n    /**\n     * @see BaseDirective._mqActivation\n     * @return {?}\n     */\n    get mqActivation() {\n        return /** @type {?} */ ((this._mqActivation));\n    }\n    /**\n     * Does this directive have 1 or more responsive keys defined\n     * Note: we exclude the 'baseKey' key (which is NOT considered responsive)\n     * @return {?}\n     */\n    hasResponsiveAPI() {\n        return super.hasResponsiveAPI(this._baseKey);\n    }\n    /**\n     * @see BaseDirective._queryInput\n     * @param {?} key\n     * @return {?}\n     */\n    queryInput(key) {\n        return key ? this._queryInput(key) : undefined;\n    }\n    /**\n     *  Save the property value.\n     * @param {?=} key\n     * @param {?=} source\n     * @param {?=} cacheRaw\n     * @return {?}\n     */\n    cacheInput(key, source, cacheRaw = false) {\n        if (cacheRaw) {\n            this._cacheInputRaw(key, source);\n        }\n        else if (Array.isArray(source)) {\n            this._cacheInputArray(key, source);\n        }\n        else if (typeof source === 'object') {\n            this._cacheInputObject(key, source);\n        }\n        else if (typeof source === 'string') {\n            this._cacheInputString(key, source);\n        }\n        else {\n            throw new Error(`Invalid class value '${key}' provided. Did you want to cache the raw value?`);\n        }\n    }\n    /**\n     * @see BaseDirective._listenForMediaQueryChanges\n     * @param {?} key\n     * @param {?} defaultValue\n     * @param {?} onMediaQueryChange\n     * @return {?}\n     */\n    listenForMediaQueryChanges(key, defaultValue, onMediaQueryChange) {\n        return this._listenForMediaQueryChanges(key, defaultValue, onMediaQueryChange);\n    }\n    /**\n     * No implicit transforms of the source.\n     * Required when caching values expected later for KeyValueDiffers\n     * @param {?=} key\n     * @param {?=} source\n     * @return {?}\n     */\n    _cacheInputRaw(key, source) {\n        if (key) {\n            this._inputMap[key] = source;\n        }\n    }\n    /**\n     *  Save the property value for Array values.\n     * @param {?=} key\n     * @param {?=} source\n     * @return {?}\n     */\n    _cacheInputArray(key = '', source) {\n        this._inputMap[key] = source ? source.join(' ') : '';\n    }\n    /**\n     *  Save the property value for key/value pair values.\n     * @param {?=} key\n     * @param {?=} source\n     * @return {?}\n     */\n    _cacheInputObject(key = '', source) {\n        /** @type {?} */\n        let classes = [];\n        if (source) {\n            for (let prop in source) {\n                if (!!source[prop]) {\n                    classes.push(prop);\n                }\n            }\n        }\n        this._inputMap[key] = classes.join(' ');\n    }\n    /**\n     *  Save the property value for string values.\n     * @param {?=} key\n     * @param {?=} source\n     * @return {?}\n     */\n    _cacheInputString(key = '', source) {\n        this._inputMap[key] = source;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * MockMatchMedia mocks calls to the Window API matchMedia with a build of a simulated\n * MockMediaQueryListener. Methods are available to simulate an activation of a mediaQuery\n * range and to clearAll mediaQuery listeners.\n */\nclass MockMatchMedia extends MatchMedia {\n    /**\n     * @param {?} _zone\n     * @param {?} _platformId\n     * @param {?} _document\n     * @param {?} _breakpoints\n     */\n    constructor(_zone, _platformId, _document, _breakpoints) {\n        super(_zone, _platformId, _document);\n        this._breakpoints = _breakpoints;\n        /**\n         * Special flag used to test BreakPoint registrations with MatchMedia\n         */\n        this.autoRegisterQueries = true;\n        /**\n         * Allow fallback to overlapping mediaQueries to determine\n         * activatedInput(s).\n         */\n        this.useOverlaps = false;\n        this._registry = new Map();\n        this._actives = [];\n        this._actives = [];\n    }\n    /**\n     * Easy method to clear all listeners for all mediaQueries\n     * @return {?}\n     */\n    clearAll() {\n        this._registry.forEach((mql) => {\n            mql.destroy();\n        });\n        this._registry.clear();\n        this.useOverlaps = false;\n    }\n    /**\n     * Feature to support manual, simulated activation of a mediaQuery.\n     * @param {?} mediaQuery\n     * @param {?=} useOverlaps\n     * @return {?}\n     */\n    activate(mediaQuery, useOverlaps = false) {\n        useOverlaps = useOverlaps || this.useOverlaps;\n        mediaQuery = this._validateQuery(mediaQuery);\n        if (useOverlaps || !this.isActive(mediaQuery)) {\n            this._deactivateAll();\n            this._registerMediaQuery(mediaQuery);\n            this._activateWithOverlaps(mediaQuery, useOverlaps);\n        }\n        return this.hasActivated;\n    }\n    /**\n     * Converts an optional mediaQuery alias to a specific, valid mediaQuery\n     * @param {?} queryOrAlias\n     * @return {?}\n     */\n    _validateQuery(queryOrAlias) {\n        /** @type {?} */\n        let bp = this._breakpoints.findByAlias(queryOrAlias);\n        if (bp) {\n            queryOrAlias = bp.mediaQuery;\n        }\n        return queryOrAlias;\n    }\n    /**\n     * Manually activate any overlapping mediaQueries to simulate\n     * similar functionality in the window.matchMedia()\n     * @param {?} mediaQuery\n     * @param {?} useOverlaps\n     * @return {?}\n     */\n    _activateWithOverlaps(mediaQuery, useOverlaps) {\n        if (useOverlaps) {\n            /** @type {?} */\n            let bp = this._breakpoints.findByQuery(mediaQuery);\n            /** @type {?} */\n            let alias = bp ? bp.alias : 'unknown';\n            // Simulate activation of overlapping lt-<XXX> ranges\n            switch (alias) {\n                case 'lg':\n                    this._activateByAlias('lt-xl');\n                    break;\n                case 'md':\n                    this._activateByAlias('lt-xl, lt-lg');\n                    break;\n                case 'sm':\n                    this._activateByAlias('lt-xl, lt-lg, lt-md');\n                    break;\n                case 'xs':\n                    this._activateByAlias('lt-xl, lt-lg, lt-md, lt-sm');\n                    break;\n            }\n            // Simulate activate of overlapping gt-<xxxx> mediaQuery ranges\n            switch (alias) {\n                case 'xl':\n                    this._activateByAlias('gt-lg, gt-md, gt-sm, gt-xs');\n                    break;\n                case 'lg':\n                    this._activateByAlias('gt-md, gt-sm, gt-xs');\n                    break;\n                case 'md':\n                    this._activateByAlias('gt-sm, gt-xs');\n                    break;\n                case 'sm':\n                    this._activateByAlias('gt-xs');\n                    break;\n            }\n        }\n        // Activate last since the responsiveActivation is watching *this* mediaQuery\n        return this._activateByQuery(mediaQuery);\n    }\n    /**\n     *\n     * @param {?} aliases\n     * @return {?}\n     */\n    _activateByAlias(aliases) {\n        /** @type {?} */\n        let activate = (alias) => {\n            /** @type {?} */\n            let bp = this._breakpoints.findByAlias(alias);\n            this._activateByQuery(bp ? bp.mediaQuery : alias);\n        };\n        aliases.split(',').forEach(alias => activate(alias.trim()));\n    }\n    /**\n     *\n     * @param {?} mediaQuery\n     * @return {?}\n     */\n    _activateByQuery(mediaQuery) {\n        /** @type {?} */\n        let mql = /** @type {?} */ (this._registry.get(mediaQuery));\n        /** @type {?} */\n        let alreadyAdded = this._actives.reduce((found, it) => {\n            return found || (mql && (it.media === mql.media));\n        }, false);\n        if (mql && !alreadyAdded) {\n            this._actives.push(mql.activate());\n        }\n        return this.hasActivated;\n    }\n    /**\n     * Deactivate all current Mock MQLs\n     * @return {?}\n     */\n    _deactivateAll() {\n        if (this._actives.length) {\n            // Deactivate all current MQLs and reset the buffer\n            for (const it of this._actives) {\n                it.deactivate();\n            }\n            this._actives = [];\n        }\n        return this;\n    }\n    /**\n     * Insure the mediaQuery is registered with MatchMedia\n     * @param {?} mediaQuery\n     * @return {?}\n     */\n    _registerMediaQuery(mediaQuery) {\n        if (!this._registry.has(mediaQuery) && this.autoRegisterQueries) {\n            this.registerQuery(mediaQuery);\n        }\n    }\n    /**\n     * Call window.matchMedia() to build a MediaQueryList; which\n     * supports 0..n listeners for activation/deactivation\n     * @param {?} query\n     * @return {?}\n     */\n    _buildMQL(query) {\n        return new MockMediaQueryList(query);\n    }\n    /**\n     * @return {?}\n     */\n    get hasActivated() {\n        return (this._actives.length > 0);\n    }\n}\nMockMatchMedia.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nMockMatchMedia.ctorParameters = () => [\n    { type: NgZone },\n    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: BreakPointRegistry }\n];\n/**\n * Special internal class to simulate a MediaQueryList and\n * - supports manual activation to simulate mediaQuery matching\n * - manages listeners\n */\nclass MockMediaQueryList {\n    /**\n     * @param {?} _mediaQuery\n     */\n    constructor(_mediaQuery) {\n        this._mediaQuery = _mediaQuery;\n        this._isActive = false;\n        this._listeners = [];\n        this.onchange = null;\n    }\n    /**\n     * @return {?}\n     */\n    get matches() {\n        return this._isActive;\n    }\n    /**\n     * @return {?}\n     */\n    get media() {\n        return this._mediaQuery;\n    }\n    /**\n     * Destroy the current list by deactivating the\n     * listeners and clearing the internal list\n     * @return {?}\n     */\n    destroy() {\n        this.deactivate();\n        this._listeners = [];\n    }\n    /**\n     * Notify all listeners that 'matches === TRUE'\n     * @return {?}\n     */\n    activate() {\n        if (!this._isActive) {\n            this._isActive = true;\n            this._listeners.forEach((callback) => {\n                /** @type {?} */\n                const cb = /** @type {?} */ ((callback));\n                cb.call(null, this);\n            });\n        }\n        return this;\n    }\n    /**\n     * Notify all listeners that 'matches === false'\n     * @return {?}\n     */\n    deactivate() {\n        if (this._isActive) {\n            this._isActive = false;\n            this._listeners.forEach((callback) => {\n                /** @type {?} */\n                const cb = /** @type {?} */ ((callback));\n                cb.call(null, this);\n            });\n        }\n        return this;\n    }\n    /**\n     * Add a listener to our internal list to activate later\n     * @param {?} listener\n     * @return {?}\n     */\n    addListener(listener) {\n        if (this._listeners.indexOf(listener) === -1) {\n            this._listeners.push(listener);\n        }\n        if (this._isActive) {\n            /** @type {?} */\n            const cb = /** @type {?} */ ((listener));\n            cb.call(null, this);\n        }\n    }\n    /**\n     * Don't need to remove listeners in the testing environment\n     * @param {?} _\n     * @return {?}\n     */\n    removeListener(_) {\n    }\n    /**\n     * @param {?} _\n     * @param {?} __\n     * @param {?=} ___\n     * @return {?}\n     */\n    addEventListener(_, __, ___) {\n    }\n    /**\n     * @param {?} _\n     * @param {?} __\n     * @param {?=} ___\n     * @return {?}\n     */\n    removeEventListener(_, __, ___) {\n    }\n    /**\n     * @param {?} _\n     * @return {?}\n     */\n    dispatchEvent(_) {\n        return false;\n    }\n}\n/** *\n * Pre-configured provider for MockMatchMedia\n  @type {?} */\nconst MockMatchMediaProvider = {\n    // tslint:disable-line:variable-name\n    provide: MatchMedia,\n    useClass: MockMatchMedia\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Special server-only class to simulate a MediaQueryList and\n * - supports manual activation to simulate mediaQuery matching\n * - manages listeners\n */\nclass ServerMediaQueryList {\n    /**\n     * @param {?} _mediaQuery\n     */\n    constructor(_mediaQuery) {\n        this._mediaQuery = _mediaQuery;\n        this._isActive = false;\n        this._listeners = [];\n        this.onchange = null;\n    }\n    /**\n     * @return {?}\n     */\n    get matches() {\n        return this._isActive;\n    }\n    /**\n     * @return {?}\n     */\n    get media() {\n        return this._mediaQuery;\n    }\n    /**\n     * Destroy the current list by deactivating the\n     * listeners and clearing the internal list\n     * @return {?}\n     */\n    destroy() {\n        this.deactivate();\n        this._listeners = [];\n    }\n    /**\n     * Notify all listeners that 'matches === TRUE'\n     * @return {?}\n     */\n    activate() {\n        if (!this._isActive) {\n            this._isActive = true;\n            this._listeners.forEach((callback) => {\n                /** @type {?} */\n                const cb = /** @type {?} */ ((callback));\n                cb.call(null, this);\n            });\n        }\n        return this;\n    }\n    /**\n     * Notify all listeners that 'matches === false'\n     * @return {?}\n     */\n    deactivate() {\n        if (this._isActive) {\n            this._isActive = false;\n            this._listeners.forEach((callback) => {\n                /** @type {?} */\n                const cb = /** @type {?} */ ((callback));\n                cb.call(null, this);\n            });\n        }\n        return this;\n    }\n    /**\n     * Add a listener to our internal list to activate later\n     * @param {?} listener\n     * @return {?}\n     */\n    addListener(listener) {\n        if (this._listeners.indexOf(listener) === -1) {\n            this._listeners.push(listener);\n        }\n        if (this._isActive) {\n            /** @type {?} */\n            const cb = /** @type {?} */ ((listener));\n            cb.call(null, this);\n        }\n    }\n    /**\n     * Don't need to remove listeners in the server environment\n     * @param {?} _\n     * @return {?}\n     */\n    removeListener(_) {\n    }\n    /**\n     * @param {?} _\n     * @param {?} __\n     * @param {?=} ___\n     * @return {?}\n     */\n    addEventListener(_, __, ___) {\n    }\n    /**\n     * @param {?} _\n     * @param {?} __\n     * @param {?=} ___\n     * @return {?}\n     */\n    removeEventListener(_, __, ___) {\n    }\n    /**\n     * @param {?} _\n     * @return {?}\n     */\n    dispatchEvent(_) {\n        return false;\n    }\n}\n/**\n * Special server-only implementation of MatchMedia that uses the above\n * ServerMediaQueryList as its internal representation\n *\n * Also contains methods to activate and deactivate breakpoints\n */\nclass ServerMatchMedia extends MatchMedia {\n    /**\n     * @param {?} _zone\n     * @param {?} _platformId\n     * @param {?} _document\n     */\n    constructor(_zone, _platformId, _document) {\n        super(_zone, _platformId, _document);\n        this._zone = _zone;\n        this._platformId = _platformId;\n        this._document = _document;\n        this._registry = new Map();\n        this._source = new BehaviorSubject(new MediaChange(true));\n        this._observable$ = this._source.asObservable();\n    }\n    /**\n     * Activate the specified breakpoint if we're on the server, no-op otherwise\n     * @param {?} bp\n     * @return {?}\n     */\n    activateBreakpoint(bp) {\n        /** @type {?} */\n        const lookupBreakpoint = this._registry.get(bp.mediaQuery);\n        if (lookupBreakpoint) {\n            lookupBreakpoint.activate();\n        }\n    }\n    /**\n     * Deactivate the specified breakpoint if we're on the server, no-op otherwise\n     * @param {?} bp\n     * @return {?}\n     */\n    deactivateBreakpoint(bp) {\n        /** @type {?} */\n        const lookupBreakpoint = this._registry.get(bp.mediaQuery);\n        if (lookupBreakpoint) {\n            lookupBreakpoint.deactivate();\n        }\n    }\n    /**\n     * Call window.matchMedia() to build a MediaQueryList; which\n     * supports 0..n listeners for activation/deactivation\n     * @param {?} query\n     * @return {?}\n     */\n    _buildMQL(query) {\n        return new ServerMediaQueryList(query);\n    }\n}\nServerMatchMedia.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nServerMatchMedia.ctorParameters = () => [\n    { type: NgZone },\n    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * MediaMonitor uses the MatchMedia service to observe mediaQuery changes (both activations and\n * deactivations). These changes are are published as MediaChange notifications.\n *\n * Note: all notifications will be performed within the\n * ng Zone to trigger change detections and component updates.\n *\n * It is the MediaMonitor that:\n *  - auto registers all known breakpoints\n *  - injects alias information into each raw MediaChange event\n *  - provides accessor to the currently active BreakPoint\n *  - publish list of overlapping BreakPoint(s); used by ResponsiveActivation\n */\nclass MediaMonitor {\n    /**\n     * @param {?} _breakpoints\n     * @param {?} _matchMedia\n     */\n    constructor(_breakpoints, _matchMedia) {\n        this._breakpoints = _breakpoints;\n        this._matchMedia = _matchMedia;\n        this._registerBreakpoints();\n    }\n    /**\n     * Read-only accessor to the list of breakpoints configured in the BreakPointRegistry provider\n     * @return {?}\n     */\n    get breakpoints() {\n        return [...this._breakpoints.items];\n    }\n    /**\n     * @return {?}\n     */\n    get activeOverlaps() {\n        /** @type {?} */\n        let items = this._breakpoints.overlappings.reverse();\n        return items.filter((bp) => {\n            return this._matchMedia.isActive(bp.mediaQuery);\n        });\n    }\n    /**\n     * @return {?}\n     */\n    get active() {\n        /** @type {?} */\n        let found = null;\n        /** @type {?} */\n        let items = this.breakpoints.reverse();\n        items.forEach(bp => {\n            if (bp.alias !== '') {\n                if (!found && this._matchMedia.isActive(bp.mediaQuery)) {\n                    found = bp;\n                }\n            }\n        });\n        /** @type {?} */\n        let first = this.breakpoints[0];\n        return found || (this._matchMedia.isActive(first.mediaQuery) ? first : null);\n    }\n    /**\n     * For the specified mediaQuery alias, is the mediaQuery range active?\n     * @param {?} alias\n     * @return {?}\n     */\n    isActive(alias) {\n        /** @type {?} */\n        let bp = this._breakpoints.findByAlias(alias) || this._breakpoints.findByQuery(alias);\n        return this._matchMedia.isActive(bp ? bp.mediaQuery : alias);\n    }\n    /**\n     * External observers can watch for all (or a specific) mql changes.\n     * If specific breakpoint is observed, only return *activated* events\n     * otherwise return all events for BOTH activated + deactivated changes.\n     * @param {?=} alias\n     * @return {?}\n     */\n    observe(alias) {\n        /** @type {?} */\n        let bp = this._breakpoints.findByAlias(alias || '') ||\n            this._breakpoints.findByQuery(alias || '');\n        /** @type {?} */\n        let hasAlias = (change) => (bp ? change.mqAlias !== '' : true);\n        /** @type {?} */\n        let media$ = this._matchMedia.observe(bp ? bp.mediaQuery : alias);\n        return media$.pipe(map(change => mergeAlias(change, bp)), filter(hasAlias));\n    }\n    /**\n     * Immediate calls to matchMedia() to establish listeners\n     * and prepare for immediate subscription notifications\n     * @return {?}\n     */\n    _registerBreakpoints() {\n        /** @type {?} */\n        let queries = this._breakpoints.sortedItems.map(bp => bp.mediaQuery);\n        this._matchMedia.registerQuery(queries);\n    }\n}\nMediaMonitor.decorators = [\n    { type: Injectable, args: [{ providedIn: 'root' },] },\n];\n/** @nocollapse */\nMediaMonitor.ctorParameters = () => [\n    { type: BreakPointRegistry },\n    { type: MatchMedia }\n];\n/** @nocollapse */ MediaMonitor.ngInjectableDef = defineInjectable({ factory: function MediaMonitor_Factory() { return new MediaMonitor(inject(BreakPointRegistry), inject(MatchMedia)); }, token: MediaMonitor, providedIn: \"root\" });\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Applies CSS prefixes to appropriate style keys.\n *\n * Note: `-ms-`, `-moz` and `-webkit-box` are no longer supported. e.g.\n *    {\n *      display: -webkit-flex;     NEW - Safari 6.1+. iOS 7.1+, BB10\n *      display: flex;             NEW, Spec - Firefox, Chrome, Opera\n *      // display: -webkit-box;   OLD - iOS 6-, Safari 3.1-6, BB7\n *      // display: -ms-flexbox;   TWEENER - IE 10\n *      // display: -moz-flexbox;  OLD - Firefox\n *    }\n * @param {?} target\n * @return {?}\n */\nfunction applyCssPrefixes(target) {\n    for (let key in target) {\n        /** @type {?} */\n        let value = target[key] || '';\n        switch (key) {\n            case 'display':\n                if (value === 'flex') {\n                    target['display'] = [\n                        '-webkit-flex',\n                        'flex'\n                    ];\n                }\n                else if (value === 'inline-flex') {\n                    target['display'] = [\n                        '-webkit-inline-flex',\n                        'inline-flex'\n                    ];\n                }\n                else {\n                    target['display'] = value;\n                }\n                break;\n            case 'align-items':\n            case 'align-self':\n            case 'align-content':\n            case 'flex':\n            case 'flex-basis':\n            case 'flex-flow':\n            case 'flex-grow':\n            case 'flex-shrink':\n            case 'flex-wrap':\n            case 'justify-content':\n                target['-webkit-' + key] = value;\n                break;\n            case 'flex-direction':\n                value = value || 'row';\n                target['-webkit-flex-direction'] = value;\n                target['flex-direction'] = value;\n                break;\n            case 'order':\n                target['order'] = target['-webkit-' + key] = isNaN(+value) ? '0' : value;\n                break;\n        }\n    }\n    return target;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nclass StyleUtils {\n    /**\n     * @param {?} _serverStylesheet\n     * @param {?} _serverModuleLoaded\n     * @param {?} _platformId\n     * @param {?} layoutConfig\n     */\n    constructor(_serverStylesheet, _serverModuleLoaded, _platformId, layoutConfig) {\n        this._serverStylesheet = _serverStylesheet;\n        this._serverModuleLoaded = _serverModuleLoaded;\n        this._platformId = _platformId;\n        this.layoutConfig = layoutConfig;\n    }\n    /**\n     * Applies styles given via string pair or object map to the directive element\n     * @param {?} element\n     * @param {?} style\n     * @param {?=} value\n     * @return {?}\n     */\n    applyStyleToElement(element, style, value = null) {\n        /** @type {?} */\n        let styles = {};\n        if (typeof style === 'string') {\n            styles[style] = value;\n            style = styles;\n        }\n        styles = this.layoutConfig.disableVendorPrefixes ? style : applyCssPrefixes(style);\n        this._applyMultiValueStyleToElement(styles, element);\n    }\n    /**\n     * Applies styles given via string pair or object map to the directive's element\n     * @param {?} style\n     * @param {?=} elements\n     * @return {?}\n     */\n    applyStyleToElements(style, elements = []) {\n        /** @type {?} */\n        const styles = this.layoutConfig.disableVendorPrefixes ? style : applyCssPrefixes(style);\n        elements.forEach(el => {\n            this._applyMultiValueStyleToElement(styles, el);\n        });\n    }\n    /**\n     * Determine the DOM element's Flexbox flow (flex-direction)\n     *\n     * Check inline style first then check computed (stylesheet) style\n     * @param {?} target\n     * @return {?}\n     */\n    getFlowDirection(target) {\n        /** @type {?} */\n        const query = 'flex-direction';\n        /** @type {?} */\n        let value = this.lookupStyle(target, query);\n        if (value === FALLBACK_STYLE) {\n            value = '';\n        }\n        /** @type {?} */\n        const hasInlineValue = this.lookupInlineStyle(target, query) ||\n            (isPlatformServer(this._platformId) && this._serverModuleLoaded) ? value : '';\n        return [value || 'row', hasInlineValue];\n    }\n    /**\n     * Find the DOM element's raw attribute value (if any)\n     * @param {?} element\n     * @param {?} attribute\n     * @return {?}\n     */\n    lookupAttributeValue(element, attribute) {\n        return element.getAttribute(attribute) || '';\n    }\n    /**\n     * Find the DOM element's inline style value (if any)\n     * @param {?} element\n     * @param {?} styleName\n     * @return {?}\n     */\n    lookupInlineStyle(element, styleName) {\n        return isPlatformBrowser(this._platformId) ?\n            element.style.getPropertyValue(styleName) : this._getServerStyle(element, styleName);\n    }\n    /**\n     * Determine the inline or inherited CSS style\n     * NOTE: platform-server has no implementation for getComputedStyle\n     * @param {?} element\n     * @param {?} styleName\n     * @param {?=} inlineOnly\n     * @return {?}\n     */\n    lookupStyle(element, styleName, inlineOnly = false) {\n        /** @type {?} */\n        let value = '';\n        if (element) {\n            /** @type {?} */\n            let immediateValue = value = this.lookupInlineStyle(element, styleName);\n            if (!immediateValue) {\n                if (isPlatformBrowser(this._platformId)) {\n                    if (!inlineOnly) {\n                        value = getComputedStyle(element).getPropertyValue(styleName);\n                    }\n                }\n                else {\n                    if (this._serverModuleLoaded) {\n                        value = this._serverStylesheet.getStyleForElement(element, styleName);\n                    }\n                }\n            }\n        }\n        // Note: 'inline' is the default of all elements, unless UA stylesheet overrides;\n        //       in which case getComputedStyle() should determine a valid value.\n        return value ? value.trim() : FALLBACK_STYLE;\n    }\n    /**\n     * Applies the styles to the element. The styles object map may contain an array of values\n     * Each value will be added as element style\n     * Keys are sorted to add prefixed styles (like -webkit-x) first, before the standard ones\n     * @param {?} styles\n     * @param {?} element\n     * @return {?}\n     */\n    _applyMultiValueStyleToElement(styles, element) {\n        Object.keys(styles).sort().forEach(key => {\n            /** @type {?} */\n            const el = styles[key];\n            /** @type {?} */\n            const values = Array.isArray(el) ? el : [el];\n            values.sort();\n            for (let value of values) {\n                value = value ? value + '' : '';\n                if (isPlatformBrowser(this._platformId) || !this._serverModuleLoaded) {\n                    isPlatformBrowser(this._platformId) ?\n                        element.style.setProperty(key, value) : this._setServerStyle(element, key, value);\n                }\n                else {\n                    this._serverStylesheet.addStyleToElement(element, key, value);\n                }\n            }\n        });\n    }\n    /**\n     * @param {?} element\n     * @param {?} styleName\n     * @param {?=} styleValue\n     * @return {?}\n     */\n    _setServerStyle(element, styleName, styleValue) {\n        styleName = styleName.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n        /** @type {?} */\n        const styleMap = this._readStyleAttribute(element);\n        styleMap[styleName] = styleValue || '';\n        this._writeStyleAttribute(element, styleMap);\n    }\n    /**\n     * @param {?} element\n     * @param {?} styleName\n     * @return {?}\n     */\n    _getServerStyle(element, styleName) {\n        /** @type {?} */\n        const styleMap = this._readStyleAttribute(element);\n        return styleMap[styleName] || '';\n    }\n    /**\n     * @param {?} element\n     * @return {?}\n     */\n    _readStyleAttribute(element) {\n        /** @type {?} */\n        const styleMap = {};\n        /** @type {?} */\n        const styleAttribute = element.getAttribute('style');\n        if (styleAttribute) {\n            /** @type {?} */\n            const styleList = styleAttribute.split(/;+/g);\n            for (let i = 0; i < styleList.length; i++) {\n                /** @type {?} */\n                const style = styleList[i].trim();\n                if (style.length > 0) {\n                    /** @type {?} */\n                    const colonIndex = style.indexOf(':');\n                    if (colonIndex === -1) {\n                        throw new Error(`Invalid CSS style: ${style}`);\n                    }\n                    /** @type {?} */\n                    const name = style.substr(0, colonIndex).trim();\n                    styleMap[name] = style.substr(colonIndex + 1).trim();\n                }\n            }\n        }\n        return styleMap;\n    }\n    /**\n     * @param {?} element\n     * @param {?} styleMap\n     * @return {?}\n     */\n    _writeStyleAttribute(element, styleMap) {\n        /** @type {?} */\n        let styleAttrValue = '';\n        for (const key in styleMap) {\n            /** @type {?} */\n            const newValue = styleMap[key];\n            if (newValue) {\n                styleAttrValue += key + ':' + styleMap[key] + ';';\n            }\n        }\n        element.setAttribute('style', styleAttrValue);\n    }\n}\nStyleUtils.decorators = [\n    { type: Injectable, args: [{ providedIn: 'root' },] },\n];\n/** @nocollapse */\nStyleUtils.ctorParameters = () => [\n    { type: StylesheetMap, decorators: [{ type: Optional }] },\n    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [SERVER_TOKEN,] }] },\n    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },\n    { type: undefined, decorators: [{ type: Inject, args: [LAYOUT_CONFIG,] }] }\n];\n/** @nocollapse */ StyleUtils.ngInjectableDef = defineInjectable({ factory: function StyleUtils_Factory() { return new StyleUtils(inject(StylesheetMap, 8), inject(SERVER_TOKEN, 8), inject(PLATFORM_ID), inject(LAYOUT_CONFIG)); }, token: StyleUtils, providedIn: \"root\" });\n/** @type {?} */\nconst FALLBACK_STYLE = 'block';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * The flex API permits 3 or 1 parts of the value:\n *    - `flex-grow flex-shrink flex-basis`, or\n *    - `flex-basis`\n * @param {?} basis\n * @param {?=} grow\n * @param {?=} shrink\n * @return {?}\n */\nfunction validateBasis(basis, grow = '1', shrink = '1') {\n    /** @type {?} */\n    let parts = [grow, shrink, basis];\n    /** @type {?} */\n    let j = basis.indexOf('calc');\n    if (j > 0) {\n        parts[2] = _validateCalcValue(basis.substring(j).trim());\n        /** @type {?} */\n        let matches = basis.substr(0, j).trim().split(' ');\n        if (matches.length == 2) {\n            parts[0] = matches[0];\n            parts[1] = matches[1];\n        }\n    }\n    else if (j == 0) {\n        parts[2] = _validateCalcValue(basis.trim());\n    }\n    else {\n        /** @type {?} */\n        let matches = basis.split(' ');\n        parts = (matches.length === 3) ? matches : [\n            grow, shrink, basis\n        ];\n    }\n    return parts;\n}\n/**\n * Calc expressions require whitespace before & after any expression operators\n * This is a simple, crude whitespace padding solution.\n *   - '3 3 calc(15em + 20px)'\n *   - calc(100% / 7 * 2)\n *   - 'calc(15em + 20px)'\n *   - 'calc(15em+20px)'\n *   - '37px'\n *   = '43%'\n * @param {?} calc\n * @return {?}\n */\nfunction _validateCalcValue(calc) {\n    return calc.replace(/[\\s]/g, '').replace(/[\\/\\*\\+\\-]/g, ' $& ');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\nexport { removeStyles, BROWSER_PROVIDER, CLASS_NAME, CoreModule, MediaChange, StylesheetMap, DEFAULT_CONFIG, LAYOUT_CONFIG, SERVER_TOKEN, BREAKPOINT, BaseDirective, BaseDirectiveAdapter, RESPONSIVE_ALIASES, DEFAULT_BREAKPOINTS, ScreenTypes, ORIENTATION_BREAKPOINTS, BreakPointRegistry, BREAKPOINTS, MatchMedia, MockMatchMedia, MockMediaQueryList, MockMatchMediaProvider, ServerMediaQueryList, ServerMatchMedia, MediaMonitor, ObservableMedia, MediaService, ObservableMediaProvider, KeyOptions, ResponsiveActivation, StyleUtils, validateBasis };\n"]}