{"version":3,"sources":["/Users/abhishekkargawal/Documents/Nupur/policies-list/PolicyClient/node_modules/@angular/flex-layout/esm2015/grid.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;AAgBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuLC,qrCAQC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAsBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwOD,uzCAUC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAuBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0LD,6tCAUC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAuBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkJD,uiCAQC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAsBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA+JD,qmCAQC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAuBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgKD,ukCAQC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAuBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkJD,mmCAQC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAsBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0KD,iqCAQC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAuBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4JD,yiCAQC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAuBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkJD,ygCAQC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAsBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0KD,ukCAQC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAuBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0BD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAOC","file":"grid.js","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, ElementRef, Input, NgModule } from '@angular/core';\nimport { BaseDirective, MediaMonitor, StyleUtils, CoreModule } from '@angular/flex-layout/core';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst CACHE_KEY = 'align';\n/** @type {?} */\nconst ROW_DEFAULT = 'stretch';\n/** @type {?} */\nconst COL_DEFAULT = 'stretch';\n/**\n * 'align' CSS Grid styling directive for grid children\n *  Defines positioning of child elements along row and column axis in a grid container\n *  Optional values: {row-axis} values or {row-axis column-axis} value pairs\n *\n * @see https://css-tricks.com/snippets/css/complete-guide-grid/#prop-justify-self\n * @see https://css-tricks.com/snippets/css/complete-guide-grid/#prop-align-self\n */\nclass GridAlignDirective extends BaseDirective {\n    /**\n     * @param {?} monitor\n     * @param {?} elRef\n     * @param {?} styleUtils\n     */\n    constructor(monitor, elRef, styleUtils) {\n        super(monitor, elRef, styleUtils);\n    }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set align(val) { this._cacheInput(`${CACHE_KEY}`, val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignXs(val) { this._cacheInput(`${CACHE_KEY}Xs`, val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignSm(val) { this._cacheInput(`${CACHE_KEY}Sm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignMd(val) { this._cacheInput(`${CACHE_KEY}Md`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLg(val) { this._cacheInput(`${CACHE_KEY}Lg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignXl(val) { this._cacheInput(`${CACHE_KEY}Xl`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtXs(val) { this._cacheInput(`${CACHE_KEY}GtXs`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtSm(val) { this._cacheInput(`${CACHE_KEY}GtSm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtMd(val) { this._cacheInput(`${CACHE_KEY}GtMd`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtLg(val) { this._cacheInput(`${CACHE_KEY}GtLg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtSm(val) { this._cacheInput(`${CACHE_KEY}LtSm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtMd(val) { this._cacheInput(`${CACHE_KEY}LtMd`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtLg(val) { this._cacheInput(`${CACHE_KEY}LtLg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtXl(val) { this._cacheInput(`${CACHE_KEY}LtXl`, val); }\n    ;\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (changes[CACHE_KEY] != null || this._mqActivation) {\n            this._updateWithValue();\n        }\n    }\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n    ngOnInit() {\n        super.ngOnInit();\n        this._listenForMediaQueryChanges(CACHE_KEY, ROW_DEFAULT, (changes) => {\n            this._updateWithValue(changes.value);\n        });\n        this._updateWithValue();\n    }\n    /**\n     *\n     * @param {?=} value\n     * @return {?}\n     */\n    _updateWithValue(value) {\n        value = value || this._queryInput(CACHE_KEY) || ROW_DEFAULT;\n        if (this._mqActivation) {\n            value = this._mqActivation.activatedInput;\n        }\n        this._applyStyleToElement(this._buildCSS(value));\n    }\n    /**\n     * @param {?=} align\n     * @return {?}\n     */\n    _buildCSS(align = '') {\n        /** @type {?} */\n        let css = {};\n        let [rowAxis, columnAxis] = align.split(' ');\n        // Row axis\n        switch (rowAxis) {\n            case 'end':\n                css['justify-self'] = 'end';\n                break;\n            case 'center':\n                css['justify-self'] = 'center';\n                break;\n            case 'stretch':\n                css['justify-self'] = 'stretch';\n                break;\n            case 'start':\n                css['justify-self'] = 'start';\n                break;\n            default:\n                css['justify-self'] = ROW_DEFAULT; // default row axis\n                break;\n        }\n        // Column axis\n        switch (columnAxis) {\n            case 'end':\n                css['align-self'] = 'end';\n                break;\n            case 'center':\n                css['align-self'] = 'center';\n                break;\n            case 'stretch':\n                css['align-self'] = 'stretch';\n                break;\n            case 'start':\n                css['align-self'] = 'start';\n                break;\n            default:\n                css['align-self'] = COL_DEFAULT; // default column axis\n                break;\n        }\n        return css;\n    }\n}\nGridAlignDirective.decorators = [\n    { type: Directive, args: [{ selector: `\n  [gdGridAlign],\n  [gdGridAlign.xs], [gdGridAlign.sm], [gdGridAlign.md], [gdGridAlign.lg],[gdGridAlign.xl],\n  [gdGridAlign.lt-sm], [gdGridAlign.lt-md], [gdGridAlign.lt-lg], [gdGridAlign.lt-xl],\n  [gdGridAlign.gt-xs], [gdGridAlign.gt-sm], [gdGridAlign.gt-md], [gdGridAlign.gt-lg]\n` },] },\n];\n/** @nocollapse */\nGridAlignDirective.ctorParameters = () => [\n    { type: MediaMonitor },\n    { type: ElementRef },\n    { type: StyleUtils }\n];\nGridAlignDirective.propDecorators = {\n    align: [{ type: Input, args: ['gdGridAlign',] }],\n    alignXs: [{ type: Input, args: ['gdGridAlign.xs',] }],\n    alignSm: [{ type: Input, args: ['gdGridAlign.sm',] }],\n    alignMd: [{ type: Input, args: ['gdGridAlign.md',] }],\n    alignLg: [{ type: Input, args: ['gdGridAlign.lg',] }],\n    alignXl: [{ type: Input, args: ['gdGridAlign.xl',] }],\n    alignGtXs: [{ type: Input, args: ['gdGridAlign.gt-xs',] }],\n    alignGtSm: [{ type: Input, args: ['gdGridAlign.gt-sm',] }],\n    alignGtMd: [{ type: Input, args: ['gdGridAlign.gt-md',] }],\n    alignGtLg: [{ type: Input, args: ['gdGridAlign.gt-lg',] }],\n    alignLtSm: [{ type: Input, args: ['gdGridAlign.lt-sm',] }],\n    alignLtMd: [{ type: Input, args: ['gdGridAlign.lt-md',] }],\n    alignLtLg: [{ type: Input, args: ['gdGridAlign.lt-lg',] }],\n    alignLtXl: [{ type: Input, args: ['gdGridAlign.lt-xl',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Extends an object with the *enumerable* and *own* properties of one or more source objects,\n * similar to Object.assign.\n *\n * @param {?} dest The object which will have properties copied to it.\n * @param {...?} sources The source objects from which properties will be copied.\n * @return {?}\n */\nfunction extendObject(dest, ...sources) {\n    if (dest == null) {\n        throw TypeError('Cannot convert undefined or null to object');\n    }\n    for (let source of sources) {\n        if (source != null) {\n            for (let key in source) {\n                if (source.hasOwnProperty(key)) {\n                    dest[key] = source[key];\n                }\n            }\n        }\n    }\n    return dest;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst CACHE_KEY$1 = 'alignColumns';\n/** @type {?} */\nconst DEFAULT_MAIN = 'start';\n/** @type {?} */\nconst DEFAULT_CROSS = 'stretch';\n/**\n * 'column alignment' CSS Grid styling directive\n * Configures the alignment in the column direction\n * @see https://css-tricks.com/snippets/css/complete-guide-grid/#article-header-id-19\n * @see https://css-tricks.com/snippets/css/complete-guide-grid/#article-header-id-21\n */\nclass GridAlignColumnsDirective extends BaseDirective {\n    /**\n     * @param {?} monitor\n     * @param {?} elRef\n     * @param {?} styleUtils\n     */\n    constructor(monitor, elRef, styleUtils) {\n        super(monitor, elRef, styleUtils);\n    }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set align(val) { this._cacheInput(`${CACHE_KEY$1}`, val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignXs(val) { this._cacheInput(`${CACHE_KEY$1}Xs`, val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignSm(val) { this._cacheInput(`${CACHE_KEY$1}Sm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignMd(val) { this._cacheInput(`${CACHE_KEY$1}Md`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLg(val) { this._cacheInput(`${CACHE_KEY$1}Lg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignXl(val) { this._cacheInput(`${CACHE_KEY$1}Xl`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtXs(val) { this._cacheInput(`${CACHE_KEY$1}GtXs`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtSm(val) { this._cacheInput(`${CACHE_KEY$1}GtSm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtMd(val) { this._cacheInput(`${CACHE_KEY$1}GtMd`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtLg(val) { this._cacheInput(`${CACHE_KEY$1}GtLg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtSm(val) { this._cacheInput(`${CACHE_KEY$1}LtSm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtMd(val) { this._cacheInput(`${CACHE_KEY$1}LtMd`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtLg(val) { this._cacheInput(`${CACHE_KEY$1}LtLg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtXl(val) { this._cacheInput(`${CACHE_KEY$1}LtXl`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set inline(val) { this._cacheInput('inline', coerceBooleanProperty(val)); }\n    ;\n    /**\n     * For \\@Input changes on the current mq activation property, see onMediaQueryChanges()\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (changes[CACHE_KEY$1] != null || this._mqActivation) {\n            this._updateWithValue();\n        }\n    }\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n    ngOnInit() {\n        super.ngOnInit();\n        this._listenForMediaQueryChanges(CACHE_KEY$1, `${DEFAULT_MAIN} ${DEFAULT_CROSS}`, (changes) => {\n            this._updateWithValue(changes.value);\n        });\n        this._updateWithValue();\n    }\n    /**\n     * @param {?=} value\n     * @return {?}\n     */\n    _updateWithValue(value) {\n        value = value || this._queryInput(CACHE_KEY$1) || `${DEFAULT_MAIN} ${DEFAULT_CROSS}`;\n        if (this._mqActivation) {\n            value = this._mqActivation.activatedInput;\n        }\n        this._applyStyleToElement(this._buildCSS(value));\n    }\n    /**\n     * @param {?=} align\n     * @return {?}\n     */\n    _buildCSS(align = '') {\n        /** @type {?} */\n        let css = {};\n        let [mainAxis, crossAxis] = align.split(' ');\n        // Main axis\n        switch (mainAxis) {\n            case 'center':\n                css['align-content'] = 'center';\n                break;\n            case 'space-around':\n                css['align-content'] = 'space-around';\n                break;\n            case 'space-between':\n                css['align-content'] = 'space-between';\n                break;\n            case 'space-evenly':\n                css['align-content'] = 'space-evenly';\n                break;\n            case 'end':\n                css['align-content'] = 'end';\n                break;\n            case 'start':\n                css['align-content'] = 'start';\n                break;\n            case 'stretch':\n                css['align-content'] = 'stretch';\n                break;\n            default:\n                css['align-content'] = DEFAULT_MAIN; // default main axis\n                break;\n        }\n        // Cross-axis\n        switch (crossAxis) {\n            case 'start':\n                css['align-items'] = 'start';\n                break;\n            case 'center':\n                css['align-items'] = 'center';\n                break;\n            case 'end':\n                css['align-items'] = 'end';\n                break;\n            case 'stretch':\n                css['align-items'] = 'stretch';\n                break;\n            default: // 'stretch'\n                // 'stretch'\n                css['align-items'] = DEFAULT_CROSS; // default cross axis\n                break;\n        }\n        return extendObject(css, { 'display': this._queryInput('inline') ? 'inline-grid' : 'grid' });\n    }\n}\nGridAlignColumnsDirective.decorators = [\n    { type: Directive, args: [{ selector: `\n  [gdAlignColumns],\n  [gdAlignColumns.xs], [gdAlignColumns.sm], [gdAlignColumns.md],\n  [gdAlignColumns.lg], [gdAlignColumns.xl], [gdAlignColumns.lt-sm],\n  [gdAlignColumns.lt-md], [gdAlignColumns.lt-lg], [gdAlignColumns.lt-xl],\n  [gdAlignColumns.gt-xs], [gdAlignColumns.gt-sm], [gdAlignColumns.gt-md],\n  [gdAlignColumns.gt-lg]\n` },] },\n];\n/** @nocollapse */\nGridAlignColumnsDirective.ctorParameters = () => [\n    { type: MediaMonitor },\n    { type: ElementRef },\n    { type: StyleUtils }\n];\nGridAlignColumnsDirective.propDecorators = {\n    align: [{ type: Input, args: ['gdAlignColumns',] }],\n    alignXs: [{ type: Input, args: ['gdAlignColumns.xs',] }],\n    alignSm: [{ type: Input, args: ['gdAlignColumns.sm',] }],\n    alignMd: [{ type: Input, args: ['gdAlignColumns.md',] }],\n    alignLg: [{ type: Input, args: ['gdAlignColumns.lg',] }],\n    alignXl: [{ type: Input, args: ['gdAlignColumns.xl',] }],\n    alignGtXs: [{ type: Input, args: ['gdAlignColumns.gt-xs',] }],\n    alignGtSm: [{ type: Input, args: ['gdAlignColumns.gt-sm',] }],\n    alignGtMd: [{ type: Input, args: ['gdAlignColumns.gt-md',] }],\n    alignGtLg: [{ type: Input, args: ['gdAlignColumns.gt-lg',] }],\n    alignLtSm: [{ type: Input, args: ['gdAlignColumns.lt-sm',] }],\n    alignLtMd: [{ type: Input, args: ['gdAlignColumns.lt-md',] }],\n    alignLtLg: [{ type: Input, args: ['gdAlignColumns.lt-lg',] }],\n    alignLtXl: [{ type: Input, args: ['gdAlignColumns.lt-xl',] }],\n    inline: [{ type: Input, args: ['gdInline',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst CACHE_KEY$2 = 'alignRows';\n/** @type {?} */\nconst DEFAULT_MAIN$1 = 'start';\n/** @type {?} */\nconst DEFAULT_CROSS$1 = 'stretch';\n/**\n * 'row alignment' CSS Grid styling directive\n * Configures the alignment in the row direction\n * @see https://css-tricks.com/snippets/css/complete-guide-grid/#article-header-id-18\n * @see https://css-tricks.com/snippets/css/complete-guide-grid/#article-header-id-20\n */\nclass GridAlignRowsDirective extends BaseDirective {\n    /**\n     * @param {?} monitor\n     * @param {?} elRef\n     * @param {?} styleUtils\n     */\n    constructor(monitor, elRef, styleUtils) {\n        super(monitor, elRef, styleUtils);\n    }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set align(val) { this._cacheInput(`${CACHE_KEY$2}`, val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignXs(val) { this._cacheInput(`${CACHE_KEY$2}Xs`, val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignSm(val) { this._cacheInput(`${CACHE_KEY$2}Sm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignMd(val) { this._cacheInput(`${CACHE_KEY$2}Md`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLg(val) { this._cacheInput(`${CACHE_KEY$2}Lg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignXl(val) { this._cacheInput(`${CACHE_KEY$2}Xl`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtXs(val) { this._cacheInput(`${CACHE_KEY$2}GtXs`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtSm(val) { this._cacheInput(`${CACHE_KEY$2}GtSm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtMd(val) { this._cacheInput(`${CACHE_KEY$2}GtMd`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtLg(val) { this._cacheInput(`${CACHE_KEY$2}GtLg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtSm(val) { this._cacheInput(`${CACHE_KEY$2}LtSm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtMd(val) { this._cacheInput(`${CACHE_KEY$2}LtMd`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtLg(val) { this._cacheInput(`${CACHE_KEY$2}LtLg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtXl(val) { this._cacheInput(`${CACHE_KEY$2}LtXl`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set inline(val) { this._cacheInput('inline', coerceBooleanProperty(val)); }\n    ;\n    /**\n     * For \\@Input changes on the current mq activation property, see onMediaQueryChanges()\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (changes[CACHE_KEY$2] != null || this._mqActivation) {\n            this._updateWithValue();\n        }\n    }\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n    ngOnInit() {\n        super.ngOnInit();\n        this._listenForMediaQueryChanges(CACHE_KEY$2, `${DEFAULT_MAIN$1} ${DEFAULT_CROSS$1}`, (changes) => {\n            this._updateWithValue(changes.value);\n        });\n        this._updateWithValue();\n    }\n    /**\n     * @param {?=} value\n     * @return {?}\n     */\n    _updateWithValue(value) {\n        value = value || this._queryInput(CACHE_KEY$2) || `${DEFAULT_MAIN$1} ${DEFAULT_CROSS$1}`;\n        if (this._mqActivation) {\n            value = this._mqActivation.activatedInput;\n        }\n        this._applyStyleToElement(this._buildCSS(value));\n    }\n    /**\n     * @param {?=} align\n     * @return {?}\n     */\n    _buildCSS(align = '') {\n        /** @type {?} */\n        let css = {};\n        let [mainAxis, crossAxis] = align.split(' ');\n        // Main axis\n        switch (mainAxis) {\n            case 'center':\n            case 'space-around':\n            case 'space-between':\n            case 'space-evenly':\n            case 'end':\n            case 'start':\n            case 'stretch':\n                css['justify-content'] = mainAxis;\n                break;\n            default:\n                css['justify-content'] = DEFAULT_MAIN$1; // default main axis\n                break;\n        }\n        // Cross-axis\n        switch (crossAxis) {\n            case 'start':\n            case 'center':\n            case 'end':\n            case 'stretch':\n                css['justify-items'] = crossAxis;\n                break;\n            default: // 'stretch'\n                // 'stretch'\n                css['justify-items'] = DEFAULT_CROSS$1; // default cross axis\n                break;\n        }\n        return extendObject(css, { 'display': this._queryInput('inline') ? 'inline-grid' : 'grid' });\n    }\n}\nGridAlignRowsDirective.decorators = [\n    { type: Directive, args: [{ selector: `\n  [gdAlignRows],\n  [gdAlignRows.xs], [gdAlignRows.sm], [gdAlignRows.md],\n  [gdAlignRows.lg], [gdAlignRows.xl], [gdAlignRows.lt-sm],\n  [gdAlignRows.lt-md], [gdAlignRows.lt-lg], [gdAlignRows.lt-xl],\n  [gdAlignRows.gt-xs], [gdAlignRows.gt-sm], [gdAlignRows.gt-md],\n  [gdAlignRows.gt-lg]\n` },] },\n];\n/** @nocollapse */\nGridAlignRowsDirective.ctorParameters = () => [\n    { type: MediaMonitor },\n    { type: ElementRef },\n    { type: StyleUtils }\n];\nGridAlignRowsDirective.propDecorators = {\n    align: [{ type: Input, args: ['gdAlignRows',] }],\n    alignXs: [{ type: Input, args: ['gdAlignRows.xs',] }],\n    alignSm: [{ type: Input, args: ['gdAlignRows.sm',] }],\n    alignMd: [{ type: Input, args: ['gdAlignRows.md',] }],\n    alignLg: [{ type: Input, args: ['gdAlignRows.lg',] }],\n    alignXl: [{ type: Input, args: ['gdAlignRows.xl',] }],\n    alignGtXs: [{ type: Input, args: ['gdAlignRows.gt-xs',] }],\n    alignGtSm: [{ type: Input, args: ['gdAlignRows.gt-sm',] }],\n    alignGtMd: [{ type: Input, args: ['gdAlignRows.gt-md',] }],\n    alignGtLg: [{ type: Input, args: ['gdAlignRows.gt-lg',] }],\n    alignLtSm: [{ type: Input, args: ['gdAlignRows.lt-sm',] }],\n    alignLtMd: [{ type: Input, args: ['gdAlignRows.lt-md',] }],\n    alignLtLg: [{ type: Input, args: ['gdAlignRows.lt-lg',] }],\n    alignLtXl: [{ type: Input, args: ['gdAlignRows.lt-xl',] }],\n    inline: [{ type: Input, args: ['gdInline',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst CACHE_KEY$3 = 'area';\n/** @type {?} */\nconst DEFAULT_VALUE = 'auto';\n/**\n * 'grid-area' CSS Grid styling directive\n * Configures the name or position of an element within the grid\n * @see https://css-tricks.com/snippets/css/complete-guide-grid/#article-header-id-27\n */\nclass GridAreaDirective extends BaseDirective {\n    /**\n     * @param {?} monitor\n     * @param {?} elRef\n     * @param {?} styleUtils\n     */\n    constructor(monitor, elRef, styleUtils) {\n        super(monitor, elRef, styleUtils);\n    }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set align(val) { this._cacheInput(`${CACHE_KEY$3}`, val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignXs(val) { this._cacheInput(`${CACHE_KEY$3}Xs`, val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignSm(val) { this._cacheInput(`${CACHE_KEY$3}Sm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignMd(val) { this._cacheInput(`${CACHE_KEY$3}Md`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLg(val) { this._cacheInput(`${CACHE_KEY$3}Lg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignXl(val) { this._cacheInput(`${CACHE_KEY$3}Xl`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtXs(val) { this._cacheInput(`${CACHE_KEY$3}GtXs`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtSm(val) { this._cacheInput(`${CACHE_KEY$3}GtSm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtMd(val) { this._cacheInput(`${CACHE_KEY$3}GtMd`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtLg(val) { this._cacheInput(`${CACHE_KEY$3}GtLg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtSm(val) { this._cacheInput(`${CACHE_KEY$3}LtSm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtMd(val) { this._cacheInput(`${CACHE_KEY$3}LtMd`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtLg(val) { this._cacheInput(`${CACHE_KEY$3}LtLg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtXl(val) { this._cacheInput(`${CACHE_KEY$3}LtXl`, val); }\n    ;\n    /**\n     * For \\@Input changes on the current mq activation property, see onMediaQueryChanges()\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (changes[CACHE_KEY$3] != null || this._mqActivation) {\n            this._updateWithValue();\n        }\n    }\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n    ngOnInit() {\n        super.ngOnInit();\n        this._listenForMediaQueryChanges(CACHE_KEY$3, DEFAULT_VALUE, (changes) => {\n            this._updateWithValue(changes.value);\n        });\n        this._updateWithValue();\n    }\n    /**\n     * @param {?=} value\n     * @return {?}\n     */\n    _updateWithValue(value) {\n        value = value || this._queryInput(CACHE_KEY$3) || DEFAULT_VALUE;\n        if (this._mqActivation) {\n            value = this._mqActivation.activatedInput;\n        }\n        this._applyStyleToElement(this._buildCSS(value));\n    }\n    /**\n     * @param {?=} value\n     * @return {?}\n     */\n    _buildCSS(value = '') {\n        return { 'grid-area': value };\n    }\n}\nGridAreaDirective.decorators = [\n    { type: Directive, args: [{ selector: `\n  [gdArea],\n  [gdArea.xs], [gdArea.sm], [gdArea.md], [gdArea.lg], [gdArea.xl],\n  [gdArea.lt-sm], [gdArea.lt-md], [gdArea.lt-lg], [gdArea.lt-xl],\n  [gdArea.gt-xs], [gdArea.gt-sm], [gdArea.gt-md], [gdArea.gt-lg]\n` },] },\n];\n/** @nocollapse */\nGridAreaDirective.ctorParameters = () => [\n    { type: MediaMonitor },\n    { type: ElementRef },\n    { type: StyleUtils }\n];\nGridAreaDirective.propDecorators = {\n    align: [{ type: Input, args: ['gdArea',] }],\n    alignXs: [{ type: Input, args: ['gdArea.xs',] }],\n    alignSm: [{ type: Input, args: ['gdArea.sm',] }],\n    alignMd: [{ type: Input, args: ['gdArea.md',] }],\n    alignLg: [{ type: Input, args: ['gdArea.lg',] }],\n    alignXl: [{ type: Input, args: ['gdArea.xl',] }],\n    alignGtXs: [{ type: Input, args: ['gdArea.gt-xs',] }],\n    alignGtSm: [{ type: Input, args: ['gdArea.gt-sm',] }],\n    alignGtMd: [{ type: Input, args: ['gdArea.gt-md',] }],\n    alignGtLg: [{ type: Input, args: ['gdArea.gt-lg',] }],\n    alignLtSm: [{ type: Input, args: ['gdArea.lt-sm',] }],\n    alignLtMd: [{ type: Input, args: ['gdArea.lt-md',] }],\n    alignLtLg: [{ type: Input, args: ['gdArea.lt-lg',] }],\n    alignLtXl: [{ type: Input, args: ['gdArea.lt-xl',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst CACHE_KEY$4 = 'areas';\n/** @type {?} */\nconst DEFAULT_VALUE$1 = 'none';\n/** @type {?} */\nconst DELIMETER = '|';\n/**\n * 'grid-template-areas' CSS Grid styling directive\n * Configures the names of elements within the grid\n * @see https://css-tricks.com/snippets/css/complete-guide-grid/#article-header-id-14\n */\nclass GridAreasDirective extends BaseDirective {\n    /**\n     * @param {?} monitor\n     * @param {?} elRef\n     * @param {?} styleUtils\n     */\n    constructor(monitor, elRef, styleUtils) {\n        super(monitor, elRef, styleUtils);\n    }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set align(val) { this._cacheInput(`${CACHE_KEY$4}`, val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignXs(val) { this._cacheInput(`${CACHE_KEY$4}Xs`, val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignSm(val) { this._cacheInput(`${CACHE_KEY$4}Sm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignMd(val) { this._cacheInput(`${CACHE_KEY$4}Md`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLg(val) { this._cacheInput(`${CACHE_KEY$4}Lg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignXl(val) { this._cacheInput(`${CACHE_KEY$4}Xl`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtXs(val) { this._cacheInput(`${CACHE_KEY$4}GtXs`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtSm(val) { this._cacheInput(`${CACHE_KEY$4}GtSm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtMd(val) { this._cacheInput(`${CACHE_KEY$4}GtMd`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtLg(val) { this._cacheInput(`${CACHE_KEY$4}GtLg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtSm(val) { this._cacheInput(`${CACHE_KEY$4}LtSm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtMd(val) { this._cacheInput(`${CACHE_KEY$4}LtMd`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtLg(val) { this._cacheInput(`${CACHE_KEY$4}LtLg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtXl(val) { this._cacheInput(`${CACHE_KEY$4}LtXl`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set inline(val) { this._cacheInput('inline', coerceBooleanProperty(val)); }\n    ;\n    /**\n     * For \\@Input changes on the current mq activation property, see onMediaQueryChanges()\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (changes[CACHE_KEY$4] != null || this._mqActivation) {\n            this._updateWithValue();\n        }\n    }\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n    ngOnInit() {\n        super.ngOnInit();\n        this._listenForMediaQueryChanges(CACHE_KEY$4, DEFAULT_VALUE$1, (changes) => {\n            this._updateWithValue(changes.value);\n        });\n        this._updateWithValue();\n    }\n    /**\n     * @param {?=} value\n     * @return {?}\n     */\n    _updateWithValue(value) {\n        value = value || this._queryInput(CACHE_KEY$4) || DEFAULT_VALUE$1;\n        if (this._mqActivation) {\n            value = this._mqActivation.activatedInput;\n        }\n        this._applyStyleToElement(this._buildCSS(value));\n    }\n    /**\n     * @param {?=} value\n     * @return {?}\n     */\n    _buildCSS(value = '') {\n        /** @type {?} */\n        const areas = value.split(DELIMETER).map(v => `\"${v.trim()}\"`);\n        return {\n            'display': this._queryInput('inline') ? 'inline-grid' : 'grid',\n            'grid-template-areas': areas.join(' ')\n        };\n    }\n}\nGridAreasDirective.decorators = [\n    { type: Directive, args: [{ selector: `\n  [gdAreas],\n  [gdAreas.xs], [gdAreas.sm], [gdAreas.md], [gdAreas.lg], [gdAreas.xl],\n  [gdAreas.lt-sm], [gdAreas.lt-md], [gdAreas.lt-lg], [gdAreas.lt-xl],\n  [gdAreas.gt-xs], [gdAreas.gt-sm], [gdAreas.gt-md], [gdAreas.gt-lg]\n` },] },\n];\n/** @nocollapse */\nGridAreasDirective.ctorParameters = () => [\n    { type: MediaMonitor },\n    { type: ElementRef },\n    { type: StyleUtils }\n];\nGridAreasDirective.propDecorators = {\n    align: [{ type: Input, args: ['gdAreas',] }],\n    alignXs: [{ type: Input, args: ['gdAreas.xs',] }],\n    alignSm: [{ type: Input, args: ['gdAreas.sm',] }],\n    alignMd: [{ type: Input, args: ['gdAreas.md',] }],\n    alignLg: [{ type: Input, args: ['gdAreas.lg',] }],\n    alignXl: [{ type: Input, args: ['gdAreas.xl',] }],\n    alignGtXs: [{ type: Input, args: ['gdAreas.gt-xs',] }],\n    alignGtSm: [{ type: Input, args: ['gdAreas.gt-sm',] }],\n    alignGtMd: [{ type: Input, args: ['gdAreas.gt-md',] }],\n    alignGtLg: [{ type: Input, args: ['gdAreas.gt-lg',] }],\n    alignLtSm: [{ type: Input, args: ['gdAreas.lt-sm',] }],\n    alignLtMd: [{ type: Input, args: ['gdAreas.lt-md',] }],\n    alignLtLg: [{ type: Input, args: ['gdAreas.lt-lg',] }],\n    alignLtXl: [{ type: Input, args: ['gdAreas.lt-xl',] }],\n    inline: [{ type: Input, args: ['gdInline',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst CACHE_KEY$5 = 'autoFlow';\n/** @type {?} */\nconst DEFAULT_VALUE$2 = 'initial';\n/**\n * 'grid-auto-flow' CSS Grid styling directive\n * Configures the auto placement algorithm for the grid\n * @see https://css-tricks.com/snippets/css/complete-guide-grid/#article-header-id-23\n */\nclass GridAutoDirective extends BaseDirective {\n    /**\n     * @param {?} monitor\n     * @param {?} elRef\n     * @param {?} styleUtils\n     */\n    constructor(monitor, elRef, styleUtils) {\n        super(monitor, elRef, styleUtils);\n    }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set align(val) { this._cacheInput(`${CACHE_KEY$5}`, val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignXs(val) { this._cacheInput(`${CACHE_KEY$5}Xs`, val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignSm(val) { this._cacheInput(`${CACHE_KEY$5}Sm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignMd(val) { this._cacheInput(`${CACHE_KEY$5}Md`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLg(val) { this._cacheInput(`${CACHE_KEY$5}Lg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignXl(val) { this._cacheInput(`${CACHE_KEY$5}Xl`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtXs(val) { this._cacheInput(`${CACHE_KEY$5}GtXs`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtSm(val) { this._cacheInput(`${CACHE_KEY$5}GtSm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtMd(val) { this._cacheInput(`${CACHE_KEY$5}GtMd`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtLg(val) { this._cacheInput(`${CACHE_KEY$5}GtLg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtSm(val) { this._cacheInput(`${CACHE_KEY$5}LtSm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtMd(val) { this._cacheInput(`${CACHE_KEY$5}LtMd`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtLg(val) { this._cacheInput(`${CACHE_KEY$5}LtLg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtXl(val) { this._cacheInput(`${CACHE_KEY$5}LtXl`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set inline(val) { this._cacheInput('inline', coerceBooleanProperty(val)); }\n    ;\n    /**\n     * For \\@Input changes on the current mq activation property, see onMediaQueryChanges()\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (changes[CACHE_KEY$5] != null || this._mqActivation) {\n            this._updateWithValue();\n        }\n    }\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n    ngOnInit() {\n        super.ngOnInit();\n        this._listenForMediaQueryChanges(CACHE_KEY$5, DEFAULT_VALUE$2, (changes) => {\n            this._updateWithValue(changes.value);\n        });\n        this._updateWithValue();\n    }\n    /**\n     * @param {?=} value\n     * @return {?}\n     */\n    _updateWithValue(value) {\n        value = value || this._queryInput(CACHE_KEY$5) || DEFAULT_VALUE$2;\n        if (this._mqActivation) {\n            value = this._mqActivation.activatedInput;\n        }\n        this._applyStyleToElement(this._buildCSS(value));\n    }\n    /**\n     * @param {?=} value\n     * @return {?}\n     */\n    _buildCSS(value = '') {\n        let [direction, dense] = value.split(' ');\n        if (direction !== 'column' && direction !== 'row' && direction !== 'dense') {\n            direction = 'row';\n        }\n        dense = (dense === 'dense' && direction !== 'dense') ? ' dense' : '';\n        return {\n            'display': this._queryInput('inline') ? 'inline-grid' : 'grid',\n            'grid-auto-flow': direction + dense\n        };\n    }\n}\nGridAutoDirective.decorators = [\n    { type: Directive, args: [{ selector: `\n  [gdAuto],\n  [gdAuto.xs], [gdAuto.sm], [gdAuto.md], [gdAuto.lg], [gdAuto.xl],\n  [gdAuto.lt-sm], [gdAuto.lt-md], [gdAuto.lt-lg], [gdAuto.lt-xl],\n  [gdAuto.gt-xs], [gdAuto.gt-sm], [gdAuto.gt-md], [gdAuto.gt-lg]\n` },] },\n];\n/** @nocollapse */\nGridAutoDirective.ctorParameters = () => [\n    { type: MediaMonitor },\n    { type: ElementRef },\n    { type: StyleUtils }\n];\nGridAutoDirective.propDecorators = {\n    align: [{ type: Input, args: ['gdAuto',] }],\n    alignXs: [{ type: Input, args: ['gdAuto.xs',] }],\n    alignSm: [{ type: Input, args: ['gdAuto.sm',] }],\n    alignMd: [{ type: Input, args: ['gdAuto.md',] }],\n    alignLg: [{ type: Input, args: ['gdAuto.lg',] }],\n    alignXl: [{ type: Input, args: ['gdAuto.xl',] }],\n    alignGtXs: [{ type: Input, args: ['gdAuto.gt-xs',] }],\n    alignGtSm: [{ type: Input, args: ['gdAuto.gt-sm',] }],\n    alignGtMd: [{ type: Input, args: ['gdAuto.gt-md',] }],\n    alignGtLg: [{ type: Input, args: ['gdAuto.gt-lg',] }],\n    alignLtSm: [{ type: Input, args: ['gdAuto.lt-sm',] }],\n    alignLtMd: [{ type: Input, args: ['gdAuto.lt-md',] }],\n    alignLtLg: [{ type: Input, args: ['gdAuto.lt-lg',] }],\n    alignLtXl: [{ type: Input, args: ['gdAuto.lt-xl',] }],\n    inline: [{ type: Input, args: ['gdInline',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst CACHE_KEY$6 = 'column';\n/** @type {?} */\nconst DEFAULT_VALUE$3 = 'auto';\n/**\n * 'grid-column' CSS Grid styling directive\n * Configures the name or position of an element within the grid\n * @see https://css-tricks.com/snippets/css/complete-guide-grid/#article-header-id-26\n */\nclass GridColumnDirective extends BaseDirective {\n    /**\n     * @param {?} monitor\n     * @param {?} elRef\n     * @param {?} styleUtils\n     */\n    constructor(monitor, elRef, styleUtils) {\n        super(monitor, elRef, styleUtils);\n    }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set align(val) { this._cacheInput(`${CACHE_KEY$6}`, val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignXs(val) { this._cacheInput(`${CACHE_KEY$6}Xs`, val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignSm(val) { this._cacheInput(`${CACHE_KEY$6}Sm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignMd(val) { this._cacheInput(`${CACHE_KEY$6}Md`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLg(val) { this._cacheInput(`${CACHE_KEY$6}Lg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignXl(val) { this._cacheInput(`${CACHE_KEY$6}Xl`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtXs(val) { this._cacheInput(`${CACHE_KEY$6}GtXs`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtSm(val) { this._cacheInput(`${CACHE_KEY$6}GtSm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtMd(val) { this._cacheInput(`${CACHE_KEY$6}GtMd`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtLg(val) { this._cacheInput(`${CACHE_KEY$6}GtLg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtSm(val) { this._cacheInput(`${CACHE_KEY$6}LtSm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtMd(val) { this._cacheInput(`${CACHE_KEY$6}LtMd`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtLg(val) { this._cacheInput(`${CACHE_KEY$6}LtLg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtXl(val) { this._cacheInput(`${CACHE_KEY$6}LtXl`, val); }\n    ;\n    /**\n     * For \\@Input changes on the current mq activation property, see onMediaQueryChanges()\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (changes[CACHE_KEY$6] != null || this._mqActivation) {\n            this._updateWithValue();\n        }\n    }\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n    ngOnInit() {\n        super.ngOnInit();\n        this._listenForMediaQueryChanges(CACHE_KEY$6, DEFAULT_VALUE$3, (changes) => {\n            this._updateWithValue(changes.value);\n        });\n        this._updateWithValue();\n    }\n    /**\n     * @param {?=} value\n     * @return {?}\n     */\n    _updateWithValue(value) {\n        value = value || this._queryInput(CACHE_KEY$6) || DEFAULT_VALUE$3;\n        if (this._mqActivation) {\n            value = this._mqActivation.activatedInput;\n        }\n        this._applyStyleToElement(this._buildCSS(value));\n    }\n    /**\n     * @param {?=} value\n     * @return {?}\n     */\n    _buildCSS(value = '') {\n        return { 'grid-column': value };\n    }\n}\nGridColumnDirective.decorators = [\n    { type: Directive, args: [{ selector: `\n  [gdColumn],\n  [gdColumn.xs], [gdColumn.sm], [gdColumn.md], [gdColumn.lg], [gdColumn.xl],\n  [gdColumn.lt-sm], [gdColumn.lt-md], [gdColumn.lt-lg], [gdColumn.lt-xl],\n  [gdColumn.gt-xs], [gdColumn.gt-sm], [gdColumn.gt-md], [gdColumn.gt-lg]\n` },] },\n];\n/** @nocollapse */\nGridColumnDirective.ctorParameters = () => [\n    { type: MediaMonitor },\n    { type: ElementRef },\n    { type: StyleUtils }\n];\nGridColumnDirective.propDecorators = {\n    align: [{ type: Input, args: ['gdColumn',] }],\n    alignXs: [{ type: Input, args: ['gdColumn.xs',] }],\n    alignSm: [{ type: Input, args: ['gdColumn.sm',] }],\n    alignMd: [{ type: Input, args: ['gdColumn.md',] }],\n    alignLg: [{ type: Input, args: ['gdColumn.lg',] }],\n    alignXl: [{ type: Input, args: ['gdColumn.xl',] }],\n    alignGtXs: [{ type: Input, args: ['gdColumn.gt-xs',] }],\n    alignGtSm: [{ type: Input, args: ['gdColumn.gt-sm',] }],\n    alignGtMd: [{ type: Input, args: ['gdColumn.gt-md',] }],\n    alignGtLg: [{ type: Input, args: ['gdColumn.gt-lg',] }],\n    alignLtSm: [{ type: Input, args: ['gdColumn.lt-sm',] }],\n    alignLtMd: [{ type: Input, args: ['gdColumn.lt-md',] }],\n    alignLtLg: [{ type: Input, args: ['gdColumn.lt-lg',] }],\n    alignLtXl: [{ type: Input, args: ['gdColumn.lt-xl',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst CACHE_KEY$7 = 'columns';\n/** @type {?} */\nconst DEFAULT_VALUE$4 = 'none';\n/** @type {?} */\nconst AUTO_SPECIFIER = '!';\n/**\n * 'grid-template-columns' CSS Grid styling directive\n * Configures the sizing for the columns in the grid\n * Syntax: <column value> [auto]\n * @see https://css-tricks.com/snippets/css/complete-guide-grid/#article-header-id-13\n */\nclass GridColumnsDirective extends BaseDirective {\n    /**\n     * @param {?} monitor\n     * @param {?} elRef\n     * @param {?} styleUtils\n     */\n    constructor(monitor, elRef, styleUtils) {\n        super(monitor, elRef, styleUtils);\n    }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set align(val) { this._cacheInput(`${CACHE_KEY$7}`, val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignXs(val) { this._cacheInput(`${CACHE_KEY$7}Xs`, val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignSm(val) { this._cacheInput(`${CACHE_KEY$7}Sm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignMd(val) { this._cacheInput(`${CACHE_KEY$7}Md`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLg(val) { this._cacheInput(`${CACHE_KEY$7}Lg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignXl(val) { this._cacheInput(`${CACHE_KEY$7}Xl`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtXs(val) { this._cacheInput(`${CACHE_KEY$7}GtXs`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtSm(val) { this._cacheInput(`${CACHE_KEY$7}GtSm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtMd(val) { this._cacheInput(`${CACHE_KEY$7}GtMd`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtLg(val) { this._cacheInput(`${CACHE_KEY$7}GtLg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtSm(val) { this._cacheInput(`${CACHE_KEY$7}LtSm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtMd(val) { this._cacheInput(`${CACHE_KEY$7}LtMd`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtLg(val) { this._cacheInput(`${CACHE_KEY$7}LtLg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtXl(val) { this._cacheInput(`${CACHE_KEY$7}LtXl`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set inline(val) { this._cacheInput('inline', coerceBooleanProperty(val)); }\n    ;\n    /**\n     * For \\@Input changes on the current mq activation property, see onMediaQueryChanges()\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (changes[CACHE_KEY$7] != null || this._mqActivation) {\n            this._updateWithValue();\n        }\n    }\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n    ngOnInit() {\n        super.ngOnInit();\n        this._listenForMediaQueryChanges(CACHE_KEY$7, DEFAULT_VALUE$4, (changes) => {\n            this._updateWithValue(changes.value);\n        });\n        this._updateWithValue();\n    }\n    /**\n     * @param {?=} value\n     * @return {?}\n     */\n    _updateWithValue(value) {\n        value = value || this._queryInput(CACHE_KEY$7) || DEFAULT_VALUE$4;\n        if (this._mqActivation) {\n            value = this._mqActivation.activatedInput;\n        }\n        this._applyStyleToElement(this._buildCSS(value));\n    }\n    /**\n     * @param {?=} value\n     * @return {?}\n     */\n    _buildCSS(value = '') {\n        /** @type {?} */\n        let auto = false;\n        if (value.endsWith(AUTO_SPECIFIER)) {\n            value = value.substring(0, value.indexOf(AUTO_SPECIFIER));\n            auto = true;\n        }\n        /** @type {?} */\n        let css = {\n            'display': this._queryInput('inline') ? 'inline-grid' : 'grid',\n            'grid-auto-columns': '',\n            'grid-template-columns': '',\n        };\n        /** @type {?} */\n        const key = (auto ? 'grid-auto-columns' : 'grid-template-columns');\n        css[key] = value;\n        return css;\n    }\n}\nGridColumnsDirective.decorators = [\n    { type: Directive, args: [{ selector: `\n  [gdColumns],\n  [gdColumns.xs], [gdColumns.sm], [gdColumns.md], [gdColumns.lg], [gdColumns.xl],\n  [gdColumns.lt-sm], [gdColumns.lt-md], [gdColumns.lt-lg], [gdColumns.lt-xl],\n  [gdColumns.gt-xs], [gdColumns.gt-sm], [gdColumns.gt-md], [gdColumns.gt-lg]\n` },] },\n];\n/** @nocollapse */\nGridColumnsDirective.ctorParameters = () => [\n    { type: MediaMonitor },\n    { type: ElementRef },\n    { type: StyleUtils }\n];\nGridColumnsDirective.propDecorators = {\n    align: [{ type: Input, args: ['gdColumns',] }],\n    alignXs: [{ type: Input, args: ['gdColumns.xs',] }],\n    alignSm: [{ type: Input, args: ['gdColumns.sm',] }],\n    alignMd: [{ type: Input, args: ['gdColumns.md',] }],\n    alignLg: [{ type: Input, args: ['gdColumns.lg',] }],\n    alignXl: [{ type: Input, args: ['gdColumns.xl',] }],\n    alignGtXs: [{ type: Input, args: ['gdColumns.gt-xs',] }],\n    alignGtSm: [{ type: Input, args: ['gdColumns.gt-sm',] }],\n    alignGtMd: [{ type: Input, args: ['gdColumns.gt-md',] }],\n    alignGtLg: [{ type: Input, args: ['gdColumns.gt-lg',] }],\n    alignLtSm: [{ type: Input, args: ['gdColumns.lt-sm',] }],\n    alignLtMd: [{ type: Input, args: ['gdColumns.lt-md',] }],\n    alignLtLg: [{ type: Input, args: ['gdColumns.lt-lg',] }],\n    alignLtXl: [{ type: Input, args: ['gdColumns.lt-xl',] }],\n    inline: [{ type: Input, args: ['gdInline',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst CACHE_KEY$8 = 'gap';\n/** @type {?} */\nconst DEFAULT_VALUE$5 = '0';\n/**\n * 'grid-gap' CSS Grid styling directive\n * Configures the gap between items in the grid\n * Syntax: <row gap> [<column-gap>]\n * @see https://css-tricks.com/snippets/css/complete-guide-grid/#article-header-id-17\n */\nclass GridGapDirective extends BaseDirective {\n    /**\n     * @param {?} monitor\n     * @param {?} elRef\n     * @param {?} styleUtils\n     */\n    constructor(monitor, elRef, styleUtils) {\n        super(monitor, elRef, styleUtils);\n    }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set align(val) { this._cacheInput(`${CACHE_KEY$8}`, val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignXs(val) { this._cacheInput(`${CACHE_KEY$8}Xs`, val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignSm(val) { this._cacheInput(`${CACHE_KEY$8}Sm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignMd(val) { this._cacheInput(`${CACHE_KEY$8}Md`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLg(val) { this._cacheInput(`${CACHE_KEY$8}Lg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignXl(val) { this._cacheInput(`${CACHE_KEY$8}Xl`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtXs(val) { this._cacheInput(`${CACHE_KEY$8}GtXs`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtSm(val) { this._cacheInput(`${CACHE_KEY$8}GtSm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtMd(val) { this._cacheInput(`${CACHE_KEY$8}GtMd`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtLg(val) { this._cacheInput(`${CACHE_KEY$8}GtLg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtSm(val) { this._cacheInput(`${CACHE_KEY$8}LtSm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtMd(val) { this._cacheInput(`${CACHE_KEY$8}LtMd`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtLg(val) { this._cacheInput(`${CACHE_KEY$8}LtLg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtXl(val) { this._cacheInput(`${CACHE_KEY$8}LtXl`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set inline(val) { this._cacheInput('inline', coerceBooleanProperty(val)); }\n    ;\n    /**\n     * For \\@Input changes on the current mq activation property, see onMediaQueryChanges()\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (changes[CACHE_KEY$8] != null || this._mqActivation) {\n            this._updateWithValue();\n        }\n    }\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n    ngOnInit() {\n        super.ngOnInit();\n        this._listenForMediaQueryChanges(CACHE_KEY$8, DEFAULT_VALUE$5, (changes) => {\n            this._updateWithValue(changes.value);\n        });\n        this._updateWithValue();\n    }\n    /**\n     * @param {?=} value\n     * @return {?}\n     */\n    _updateWithValue(value) {\n        value = value || this._queryInput(CACHE_KEY$8) || DEFAULT_VALUE$5;\n        if (this._mqActivation) {\n            value = this._mqActivation.activatedInput;\n        }\n        this._applyStyleToElement(this._buildCSS(value));\n    }\n    /**\n     * @param {?=} value\n     * @return {?}\n     */\n    _buildCSS(value = '') {\n        return {\n            'display': this._queryInput('inline') ? 'inline-grid' : 'grid',\n            'grid-gap': value\n        };\n    }\n}\nGridGapDirective.decorators = [\n    { type: Directive, args: [{ selector: `\n  [gdGap],\n  [gdGap.xs], [gdGap.sm], [gdGap.md], [gdGap.lg], [gdGap.xl],\n  [gdGap.lt-sm], [gdGap.lt-md], [gdGap.lt-lg], [gdGap.lt-xl],\n  [gdGap.gt-xs], [gdGap.gt-sm], [gdGap.gt-md], [gdGap.gt-lg]\n` },] },\n];\n/** @nocollapse */\nGridGapDirective.ctorParameters = () => [\n    { type: MediaMonitor },\n    { type: ElementRef },\n    { type: StyleUtils }\n];\nGridGapDirective.propDecorators = {\n    align: [{ type: Input, args: ['gdGap',] }],\n    alignXs: [{ type: Input, args: ['gdGap.xs',] }],\n    alignSm: [{ type: Input, args: ['gdGap.sm',] }],\n    alignMd: [{ type: Input, args: ['gdGap.md',] }],\n    alignLg: [{ type: Input, args: ['gdGap.lg',] }],\n    alignXl: [{ type: Input, args: ['gdGap.xl',] }],\n    alignGtXs: [{ type: Input, args: ['gdGap.gt-xs',] }],\n    alignGtSm: [{ type: Input, args: ['gdGap.gt-sm',] }],\n    alignGtMd: [{ type: Input, args: ['gdGap.gt-md',] }],\n    alignGtLg: [{ type: Input, args: ['gdGap.gt-lg',] }],\n    alignLtSm: [{ type: Input, args: ['gdGap.lt-sm',] }],\n    alignLtMd: [{ type: Input, args: ['gdGap.lt-md',] }],\n    alignLtLg: [{ type: Input, args: ['gdGap.lt-lg',] }],\n    alignLtXl: [{ type: Input, args: ['gdGap.lt-xl',] }],\n    inline: [{ type: Input, args: ['gdInline',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst CACHE_KEY$9 = 'row';\n/** @type {?} */\nconst DEFAULT_VALUE$6 = 'auto';\n/**\n * 'grid-row' CSS Grid styling directive\n * Configures the name or position of an element within the grid\n * @see https://css-tricks.com/snippets/css/complete-guide-grid/#article-header-id-26\n */\nclass GridRowDirective extends BaseDirective {\n    /**\n     * @param {?} monitor\n     * @param {?} elRef\n     * @param {?} styleUtils\n     */\n    constructor(monitor, elRef, styleUtils) {\n        super(monitor, elRef, styleUtils);\n    }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set align(val) { this._cacheInput(`${CACHE_KEY$9}`, val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignXs(val) { this._cacheInput(`${CACHE_KEY$9}Xs`, val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignSm(val) { this._cacheInput(`${CACHE_KEY$9}Sm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignMd(val) { this._cacheInput(`${CACHE_KEY$9}Md`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLg(val) { this._cacheInput(`${CACHE_KEY$9}Lg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignXl(val) { this._cacheInput(`${CACHE_KEY$9}Xl`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtXs(val) { this._cacheInput(`${CACHE_KEY$9}GtXs`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtSm(val) { this._cacheInput(`${CACHE_KEY$9}GtSm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtMd(val) { this._cacheInput(`${CACHE_KEY$9}GtMd`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtLg(val) { this._cacheInput(`${CACHE_KEY$9}GtLg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtSm(val) { this._cacheInput(`${CACHE_KEY$9}LtSm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtMd(val) { this._cacheInput(`${CACHE_KEY$9}LtMd`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtLg(val) { this._cacheInput(`${CACHE_KEY$9}LtLg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtXl(val) { this._cacheInput(`${CACHE_KEY$9}LtXl`, val); }\n    ;\n    /**\n     * For \\@Input changes on the current mq activation property, see onMediaQueryChanges()\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (changes[CACHE_KEY$9] != null || this._mqActivation) {\n            this._updateWithValue();\n        }\n    }\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n    ngOnInit() {\n        super.ngOnInit();\n        this._listenForMediaQueryChanges(CACHE_KEY$9, DEFAULT_VALUE$6, (changes) => {\n            this._updateWithValue(changes.value);\n        });\n        this._updateWithValue();\n    }\n    /**\n     * @param {?=} value\n     * @return {?}\n     */\n    _updateWithValue(value) {\n        value = value || this._queryInput(CACHE_KEY$9) || DEFAULT_VALUE$6;\n        if (this._mqActivation) {\n            value = this._mqActivation.activatedInput;\n        }\n        this._applyStyleToElement(this._buildCSS(value));\n    }\n    /**\n     * @param {?=} value\n     * @return {?}\n     */\n    _buildCSS(value = '') {\n        return { 'grid-row': value };\n    }\n}\nGridRowDirective.decorators = [\n    { type: Directive, args: [{ selector: `\n  [gdRow],\n  [gdRow.xs], [gdRow.sm], [gdRow.md], [gdRow.lg], [gdRow.xl],\n  [gdRow.lt-sm], [gdRow.lt-md], [gdRow.lt-lg], [gdRow.lt-xl],\n  [gdRow.gt-xs], [gdRow.gt-sm], [gdRow.gt-md], [gdRow.gt-lg]\n` },] },\n];\n/** @nocollapse */\nGridRowDirective.ctorParameters = () => [\n    { type: MediaMonitor },\n    { type: ElementRef },\n    { type: StyleUtils }\n];\nGridRowDirective.propDecorators = {\n    align: [{ type: Input, args: ['gdRow',] }],\n    alignXs: [{ type: Input, args: ['gdRow.xs',] }],\n    alignSm: [{ type: Input, args: ['gdRow.sm',] }],\n    alignMd: [{ type: Input, args: ['gdRow.md',] }],\n    alignLg: [{ type: Input, args: ['gdRow.lg',] }],\n    alignXl: [{ type: Input, args: ['gdRow.xl',] }],\n    alignGtXs: [{ type: Input, args: ['gdRow.gt-xs',] }],\n    alignGtSm: [{ type: Input, args: ['gdRow.gt-sm',] }],\n    alignGtMd: [{ type: Input, args: ['gdRow.gt-md',] }],\n    alignGtLg: [{ type: Input, args: ['gdRow.gt-lg',] }],\n    alignLtSm: [{ type: Input, args: ['gdRow.lt-sm',] }],\n    alignLtMd: [{ type: Input, args: ['gdRow.lt-md',] }],\n    alignLtLg: [{ type: Input, args: ['gdRow.lt-lg',] }],\n    alignLtXl: [{ type: Input, args: ['gdRow.lt-xl',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst CACHE_KEY$10 = 'rows';\n/** @type {?} */\nconst DEFAULT_VALUE$7 = 'none';\n/** @type {?} */\nconst AUTO_SPECIFIER$1 = '!';\n/**\n * 'grid-template-rows' CSS Grid styling directive\n * Configures the sizing for the rows in the grid\n * Syntax: <row value> [auto]\n * @see https://css-tricks.com/snippets/css/complete-guide-grid/#article-header-id-13\n */\nclass GridRowsDirective extends BaseDirective {\n    /**\n     * @param {?} monitor\n     * @param {?} elRef\n     * @param {?} styleUtils\n     */\n    constructor(monitor, elRef, styleUtils) {\n        super(monitor, elRef, styleUtils);\n    }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set align(val) { this._cacheInput(`${CACHE_KEY$10}`, val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignXs(val) { this._cacheInput(`${CACHE_KEY$10}Xs`, val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignSm(val) { this._cacheInput(`${CACHE_KEY$10}Sm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignMd(val) { this._cacheInput(`${CACHE_KEY$10}Md`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLg(val) { this._cacheInput(`${CACHE_KEY$10}Lg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignXl(val) { this._cacheInput(`${CACHE_KEY$10}Xl`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtXs(val) { this._cacheInput(`${CACHE_KEY$10}GtXs`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtSm(val) { this._cacheInput(`${CACHE_KEY$10}GtSm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtMd(val) { this._cacheInput(`${CACHE_KEY$10}GtMd`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtLg(val) { this._cacheInput(`${CACHE_KEY$10}GtLg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtSm(val) { this._cacheInput(`${CACHE_KEY$10}LtSm`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtMd(val) { this._cacheInput(`${CACHE_KEY$10}LtMd`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtLg(val) { this._cacheInput(`${CACHE_KEY$10}LtLg`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtXl(val) { this._cacheInput(`${CACHE_KEY$10}LtXl`, val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set inline(val) { this._cacheInput('inline', coerceBooleanProperty(val)); }\n    ;\n    /**\n     * For \\@Input changes on the current mq activation property, see onMediaQueryChanges()\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (changes[CACHE_KEY$10] != null || this._mqActivation) {\n            this._updateWithValue();\n        }\n    }\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n    ngOnInit() {\n        super.ngOnInit();\n        this._listenForMediaQueryChanges(CACHE_KEY$10, DEFAULT_VALUE$7, (changes) => {\n            this._updateWithValue(changes.value);\n        });\n        this._updateWithValue();\n    }\n    /**\n     * @param {?=} value\n     * @return {?}\n     */\n    _updateWithValue(value) {\n        value = value || this._queryInput(CACHE_KEY$10) || DEFAULT_VALUE$7;\n        if (this._mqActivation) {\n            value = this._mqActivation.activatedInput;\n        }\n        this._applyStyleToElement(this._buildCSS(value));\n    }\n    /**\n     * @param {?=} value\n     * @return {?}\n     */\n    _buildCSS(value = '') {\n        /** @type {?} */\n        let auto = false;\n        if (value.endsWith(AUTO_SPECIFIER$1)) {\n            value = value.substring(0, value.indexOf(AUTO_SPECIFIER$1));\n            auto = true;\n        }\n        /** @type {?} */\n        let css = {\n            'display': this._queryInput('inline') ? 'inline-grid' : 'grid',\n            'grid-auto-rows': '',\n            'grid-template-rows': '',\n        };\n        /** @type {?} */\n        const key = (auto ? 'grid-auto-rows' : 'grid-template-rows');\n        css[key] = value;\n        return css;\n    }\n}\nGridRowsDirective.decorators = [\n    { type: Directive, args: [{ selector: `\n  [gdRows],\n  [gdRows.xs], [gdRows.sm], [gdRows.md], [gdRows.lg], [gdRows.xl],\n  [gdRows.lt-sm], [gdRows.lt-md], [gdRows.lt-lg], [gdRows.lt-xl],\n  [gdRows.gt-xs], [gdRows.gt-sm], [gdRows.gt-md], [gdRows.gt-lg]\n` },] },\n];\n/** @nocollapse */\nGridRowsDirective.ctorParameters = () => [\n    { type: MediaMonitor },\n    { type: ElementRef },\n    { type: StyleUtils }\n];\nGridRowsDirective.propDecorators = {\n    align: [{ type: Input, args: ['gdRows',] }],\n    alignXs: [{ type: Input, args: ['gdRows.xs',] }],\n    alignSm: [{ type: Input, args: ['gdRows.sm',] }],\n    alignMd: [{ type: Input, args: ['gdRows.md',] }],\n    alignLg: [{ type: Input, args: ['gdRows.lg',] }],\n    alignXl: [{ type: Input, args: ['gdRows.xl',] }],\n    alignGtXs: [{ type: Input, args: ['gdRows.gt-xs',] }],\n    alignGtSm: [{ type: Input, args: ['gdRows.gt-sm',] }],\n    alignGtMd: [{ type: Input, args: ['gdRows.gt-md',] }],\n    alignGtLg: [{ type: Input, args: ['gdRows.gt-lg',] }],\n    alignLtSm: [{ type: Input, args: ['gdRows.lt-sm',] }],\n    alignLtMd: [{ type: Input, args: ['gdRows.lt-md',] }],\n    alignLtLg: [{ type: Input, args: ['gdRows.lt-lg',] }],\n    alignLtXl: [{ type: Input, args: ['gdRows.lt-xl',] }],\n    inline: [{ type: Input, args: ['gdInline',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst ALL_DIRECTIVES = [\n    GridAlignDirective,\n    GridAlignColumnsDirective,\n    GridAlignRowsDirective,\n    GridAreaDirective,\n    GridAreasDirective,\n    GridAutoDirective,\n    GridColumnDirective,\n    GridColumnsDirective,\n    GridGapDirective,\n    GridRowDirective,\n    GridRowsDirective,\n];\n/**\n * *****************************************************************\n * Define module for the CSS Grid API\n * *****************************************************************\n */\nclass GridModule {\n}\nGridModule.decorators = [\n    { type: NgModule, args: [{\n                imports: [CoreModule],\n                declarations: [...ALL_DIRECTIVES],\n                exports: [...ALL_DIRECTIVES]\n            },] },\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\nexport { GridModule, GridAlignColumnsDirective as b, GridAlignRowsDirective as c, GridAreaDirective as d, GridAreasDirective as e, GridAutoDirective as f, GridColumnDirective as g, GridColumnsDirective as h, GridGapDirective as i, GridAlignDirective as a, GridRowDirective as j, GridRowsDirective as k };\n"]}