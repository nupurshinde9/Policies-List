{"version":3,"sources":["/Users/abhishekkargawal/Documents/Nupur/policies-list/PolicyClient/node_modules/@angular/flex-layout/esm2015/flex.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4OC,unCAQC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAsBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuTD,6nCAUC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAyBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwWD,mkCASC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBA0BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA+ID,qrCAQC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAsBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6MD,+uCAQC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAwBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6JD,qrCAUC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAsBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA+BD,sLAMC;;;;;;;;;;;;;uIAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAyPD,ivCAQC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAuBA;;;;;;;;;;;;;;;;;;;;;;;;;CAuBD;;;;;;;;;;;;;;;;;;;;;;;0BAOC","file":"flex.js","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, ElementRef, Input, Self, Optional, NgZone, Inject, SkipSelf, NgModule } from '@angular/core';\nimport { BaseDirective, MediaMonitor, StyleUtils, LAYOUT_CONFIG, validateBasis, CoreModule } from '@angular/flex-layout/core';\nimport { ReplaySubject } from 'rxjs';\nimport { Directionality, BidiModule } from '@angular/cdk/bidi';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n  @type {?} */\nconst INLINE = 'inline';\n/** @type {?} */\nconst LAYOUT_VALUES = ['row', 'column', 'row-reverse', 'column-reverse'];\n/**\n * Validate the direction|'direction wrap' value and then update the host's inline flexbox styles\n * @param {?} value\n * @return {?}\n */\nfunction buildLayoutCSS(value) {\n    let [direction, wrap, isInline] = validateValue(value);\n    return buildCSS(direction, wrap, isInline);\n}\n/**\n * Validate the value to be one of the acceptable value options\n * Use default fallback of 'row'\n * @param {?} value\n * @return {?}\n */\nfunction validateValue(value) {\n    value = value ? value.toLowerCase() : '';\n    let [direction, wrap, inline] = value.split(' ');\n    // First value must be the `flex-direction`\n    if (!LAYOUT_VALUES.find(x => x === direction)) {\n        direction = LAYOUT_VALUES[0];\n    }\n    if (wrap === INLINE) {\n        wrap = (inline !== INLINE) ? inline : '';\n        inline = INLINE;\n    }\n    return [direction, validateWrapValue(wrap), !!inline];\n}\n/**\n * Determine if the validated, flex-direction value specifies\n * a horizontal/row flow.\n * @param {?} value\n * @return {?}\n */\nfunction isFlowHorizontal(value) {\n    let [flow,] = validateValue(value);\n    return flow.indexOf('row') > -1;\n}\n/**\n * Convert layout-wrap='<value>' to expected flex-wrap style\n * @param {?} value\n * @return {?}\n */\nfunction validateWrapValue(value) {\n    if (!!value) {\n        switch (value.toLowerCase()) {\n            case 'reverse':\n            case 'wrap-reverse':\n            case 'reverse-wrap':\n                value = 'wrap-reverse';\n                break;\n            case 'no':\n            case 'none':\n            case 'nowrap':\n                value = 'nowrap';\n                break;\n            // All other values fallback to 'wrap'\n            default:\n                value = 'wrap';\n                break;\n        }\n    }\n    return value;\n}\n/**\n * Build the CSS that should be assigned to the element instance\n * BUG:\n *   1) min-height on a column flex container wonâ€™t apply to its flex item children in IE 10-11.\n *      Use height instead if possible; height : <xxx>vh;\n *\n *  This way any padding or border specified on the child elements are\n *  laid out and drawn inside that element's specified width and height.\n * @param {?} direction\n * @param {?=} wrap\n * @param {?=} inline\n * @return {?}\n */\nfunction buildCSS(direction, wrap = null, inline = false) {\n    return {\n        'display': inline ? 'inline-flex' : 'flex',\n        'box-sizing': 'border-box',\n        'flex-direction': direction,\n        'flex-wrap': !!wrap ? wrap : null\n    };\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * 'layout' flexbox styling directive\n * Defines the positioning flow direction for the child elements: row or column\n * Optional values: column or row (default)\n * @see https://css-tricks.com/almanac/properties/f/flex-direction/\n *\n */\nclass LayoutDirective extends BaseDirective {\n    /**\n     * @param {?} monitor\n     * @param {?} elRef\n     * @param {?} styleUtils\n     */\n    constructor(monitor, elRef, styleUtils) {\n        super(monitor, elRef, styleUtils);\n        this._announcer = new ReplaySubject(1);\n        this.layout$ = this._announcer.asObservable();\n    }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set layout(val) { this._cacheInput('layout', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set layoutXs(val) { this._cacheInput('layoutXs', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set layoutSm(val) { this._cacheInput('layoutSm', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set layoutMd(val) { this._cacheInput('layoutMd', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set layoutLg(val) { this._cacheInput('layoutLg', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set layoutXl(val) { this._cacheInput('layoutXl', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set layoutGtXs(val) { this._cacheInput('layoutGtXs', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set layoutGtSm(val) { this._cacheInput('layoutGtSm', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set layoutGtMd(val) { this._cacheInput('layoutGtMd', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set layoutGtLg(val) { this._cacheInput('layoutGtLg', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set layoutLtSm(val) { this._cacheInput('layoutLtSm', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set layoutLtMd(val) { this._cacheInput('layoutLtMd', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set layoutLtLg(val) { this._cacheInput('layoutLtLg', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set layoutLtXl(val) { this._cacheInput('layoutLtXl', val); }\n    ;\n    /**\n     * On changes to any \\@Input properties...\n     * Default to use the non-responsive Input value ('fxLayout')\n     * Then conditionally override with the mq-activated Input's current value\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (changes['layout'] != null || this._mqActivation) {\n            this._updateWithDirection();\n        }\n    }\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n    ngOnInit() {\n        super.ngOnInit();\n        this._listenForMediaQueryChanges('layout', 'row', (changes) => {\n            this._updateWithDirection(changes.value);\n        });\n    }\n    /**\n     * Validate the direction value and then update the host's inline flexbox styles\n     * @param {?=} value\n     * @return {?}\n     */\n    _updateWithDirection(value) {\n        value = value || this._queryInput('layout') || 'row';\n        if (this._mqActivation) {\n            value = this._mqActivation.activatedInput;\n        }\n        /** @type {?} */\n        let css = buildLayoutCSS(!!value ? value : '');\n        this._applyStyleToElement(css);\n        this._announcer.next({\n            direction: css['flex-direction'],\n            wrap: !!css['flex-wrap'] && css['flex-wrap'] !== 'nowrap'\n        });\n    }\n}\nLayoutDirective.decorators = [\n    { type: Directive, args: [{ selector: `\n  [fxLayout],\n  [fxLayout.xs], [fxLayout.sm], [fxLayout.md], [fxLayout.lg], [fxLayout.xl],\n  [fxLayout.lt-sm], [fxLayout.lt-md], [fxLayout.lt-lg], [fxLayout.lt-xl],\n  [fxLayout.gt-xs], [fxLayout.gt-sm], [fxLayout.gt-md], [fxLayout.gt-lg]\n` },] },\n];\n/** @nocollapse */\nLayoutDirective.ctorParameters = () => [\n    { type: MediaMonitor },\n    { type: ElementRef },\n    { type: StyleUtils }\n];\nLayoutDirective.propDecorators = {\n    layout: [{ type: Input, args: ['fxLayout',] }],\n    layoutXs: [{ type: Input, args: ['fxLayout.xs',] }],\n    layoutSm: [{ type: Input, args: ['fxLayout.sm',] }],\n    layoutMd: [{ type: Input, args: ['fxLayout.md',] }],\n    layoutLg: [{ type: Input, args: ['fxLayout.lg',] }],\n    layoutXl: [{ type: Input, args: ['fxLayout.xl',] }],\n    layoutGtXs: [{ type: Input, args: ['fxLayout.gt-xs',] }],\n    layoutGtSm: [{ type: Input, args: ['fxLayout.gt-sm',] }],\n    layoutGtMd: [{ type: Input, args: ['fxLayout.gt-md',] }],\n    layoutGtLg: [{ type: Input, args: ['fxLayout.gt-lg',] }],\n    layoutLtSm: [{ type: Input, args: ['fxLayout.lt-sm',] }],\n    layoutLtMd: [{ type: Input, args: ['fxLayout.lt-md',] }],\n    layoutLtLg: [{ type: Input, args: ['fxLayout.lt-lg',] }],\n    layoutLtXl: [{ type: Input, args: ['fxLayout.lt-xl',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * 'layout-padding' styling directive\n *  Defines padding of child elements in a layout container\n */\nclass LayoutGapDirective extends BaseDirective {\n    /**\n     * @param {?} monitor\n     * @param {?} elRef\n     * @param {?} container\n     * @param {?} _zone\n     * @param {?} _directionality\n     * @param {?} styleUtils\n     */\n    constructor(monitor, elRef, container, _zone, _directionality, styleUtils) {\n        super(monitor, elRef, styleUtils);\n        this._zone = _zone;\n        this._directionality = _directionality;\n        this._layout = 'row'; // default flex-direction\n        if (container) { // Subscribe to layout direction changes\n            // Subscribe to layout direction changes\n            this._layoutWatcher = container.layout$.subscribe(this._onLayoutChange.bind(this));\n        }\n        this._directionWatcher =\n            this._directionality.change.subscribe(this._updateWithValue.bind(this));\n    }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set gap(val) { this._cacheInput('gap', val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set gapXs(val) { this._cacheInput('gapXs', val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set gapSm(val) { this._cacheInput('gapSm', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set gapMd(val) { this._cacheInput('gapMd', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set gapLg(val) { this._cacheInput('gapLg', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set gapXl(val) { this._cacheInput('gapXl', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set gapGtXs(val) { this._cacheInput('gapGtXs', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set gapGtSm(val) { this._cacheInput('gapGtSm', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set gapGtMd(val) { this._cacheInput('gapGtMd', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set gapGtLg(val) { this._cacheInput('gapGtLg', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set gapLtSm(val) { this._cacheInput('gapLtSm', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set gapLtMd(val) { this._cacheInput('gapLtMd', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set gapLtLg(val) { this._cacheInput('gapLtLg', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set gapLtXl(val) { this._cacheInput('gapLtXl', val); }\n    ;\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (changes['gap'] != null || this._mqActivation) {\n            this._updateWithValue();\n        }\n    }\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        this._watchContentChanges();\n        this._listenForMediaQueryChanges('gap', '0', (changes) => {\n            this._updateWithValue(changes.value);\n        });\n        this._updateWithValue();\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        super.ngOnDestroy();\n        if (this._layoutWatcher) {\n            this._layoutWatcher.unsubscribe();\n        }\n        if (this._observer) {\n            this._observer.disconnect();\n        }\n        if (this._directionWatcher) {\n            this._directionWatcher.unsubscribe();\n        }\n    }\n    /**\n     * Watch for child nodes to be added... and apply the layout gap styles to each.\n     * NOTE: this does NOT! differentiate between viewChildren and contentChildren\n     * @return {?}\n     */\n    _watchContentChanges() {\n        this._zone.runOutsideAngular(() => {\n            if (typeof MutationObserver !== 'undefined') {\n                this._observer = new MutationObserver((mutations) => {\n                    /** @type {?} */\n                    const validatedChanges = (it) => {\n                        return (it.addedNodes && it.addedNodes.length > 0) ||\n                            (it.removedNodes && it.removedNodes.length > 0);\n                    };\n                    // update gap styles only for child 'added' or 'removed' events\n                    if (mutations.some(validatedChanges)) {\n                        this._updateWithValue();\n                    }\n                });\n                this._observer.observe(this.nativeElement, { childList: true });\n            }\n        });\n    }\n    /**\n     * Cache the parent container 'flex-direction' and update the 'margin' styles\n     * @param {?} layout\n     * @return {?}\n     */\n    _onLayoutChange(layout) {\n        this._layout = (layout.direction || '').toLowerCase();\n        if (!LAYOUT_VALUES.find(x => x === this._layout)) {\n            this._layout = 'row';\n        }\n        this._updateWithValue();\n    }\n    /**\n     *\n     * @param {?=} value\n     * @return {?}\n     */\n    _updateWithValue(value) {\n        /** @type {?} */\n        let gapValue = value || this._queryInput('gap') || '0';\n        if (this._mqActivation) {\n            gapValue = this._mqActivation.activatedInput;\n        }\n        /** @type {?} */\n        const items = this.childrenNodes\n            .filter(el => el.nodeType === 1 && this._getDisplayStyle(el) != 'none')\n            .sort((a, b) => {\n            /** @type {?} */\n            const orderA = +this._styler.lookupStyle(a, 'order');\n            /** @type {?} */\n            const orderB = +this._styler.lookupStyle(b, 'order');\n            if (isNaN(orderA) || isNaN(orderB) || orderA === orderB) {\n                return 0;\n            }\n            else {\n                return orderA > orderB ? 1 : -1;\n            }\n        });\n        if (items.length > 0) {\n            if (gapValue.endsWith(GRID_SPECIFIER)) {\n                gapValue = gapValue.substring(0, gapValue.indexOf(GRID_SPECIFIER));\n                // For each `element` children, set the padding\n                this._applyStyleToElements(this._buildGridPadding(gapValue), items);\n                // Add the margin to the host element\n                this._applyStyleToElement(this._buildGridMargin(gapValue));\n            }\n            else {\n                /** @type {?} */\n                const lastItem = items.pop();\n                // For each `element` children EXCEPT the last,\n                // set the margin right/bottom styles...\n                this._applyStyleToElements(this._buildCSS(gapValue), items);\n                // Clear all gaps for all visible elements\n                this._applyStyleToElements(this._buildCSS(), [lastItem]);\n            }\n        }\n    }\n    /**\n     *\n     * @param {?} value\n     * @return {?}\n     */\n    _buildGridPadding(value) {\n        /** @type {?} */\n        let paddingTop = '0px';\n        /** @type {?} */\n        let paddingRight = '0px';\n        /** @type {?} */\n        let paddingBottom = value;\n        /** @type {?} */\n        let paddingLeft = '0px';\n        if (this._directionality.value === 'rtl') {\n            paddingLeft = value;\n        }\n        else {\n            paddingRight = value;\n        }\n        return { 'padding': `${paddingTop} ${paddingRight} ${paddingBottom} ${paddingLeft}` };\n    }\n    /**\n     * Prepare margin CSS, remove any previous explicitly\n     * assigned margin assignments\n     * Note: this will not work with calc values (negative calc values are invalid)\n     * @param {?} value\n     * @return {?}\n     */\n    _buildGridMargin(value) {\n        /** @type {?} */\n        let marginTop = '0px';\n        /** @type {?} */\n        let marginRight = '0px';\n        /** @type {?} */\n        let marginBottom = '-' + value;\n        /** @type {?} */\n        let marginLeft = '0px';\n        if (this._directionality.value === 'rtl') {\n            marginLeft = '-' + value;\n        }\n        else {\n            marginRight = '-' + value;\n        }\n        return { 'margin': `${marginTop} ${marginRight} ${marginBottom} ${marginLeft}` };\n    }\n    /**\n     * Prepare margin CSS, remove any previous explicitly\n     * assigned margin assignments\n     * @param {?=} value\n     * @return {?}\n     */\n    _buildCSS(value = null) {\n        /** @type {?} */\n        let key;\n        /** @type {?} */\n        let margins = {\n            'margin-left': null,\n            'margin-right': null,\n            'margin-top': null,\n            'margin-bottom': null\n        };\n        switch (this._layout) {\n            case 'column':\n                key = 'margin-bottom';\n                break;\n            case 'column-reverse':\n                key = 'margin-top';\n                break;\n            case 'row':\n                key = this._directionality.value === 'rtl' ? 'margin-left' : 'margin-right';\n                break;\n            case 'row-reverse':\n                key = this._directionality.value === 'rtl' ? 'margin-right' : 'margin-left';\n                break;\n            default:\n                key = this._directionality.value === 'rtl' ? 'margin-left' : 'margin-right';\n                break;\n        }\n        margins[key] = value;\n        return margins;\n    }\n}\nLayoutGapDirective.decorators = [\n    { type: Directive, args: [{\n                selector: `\n  [fxLayoutGap],\n  [fxLayoutGap.xs], [fxLayoutGap.sm], [fxLayoutGap.md], [fxLayoutGap.lg], [fxLayoutGap.xl],\n  [fxLayoutGap.lt-sm], [fxLayoutGap.lt-md], [fxLayoutGap.lt-lg], [fxLayoutGap.lt-xl],\n  [fxLayoutGap.gt-xs], [fxLayoutGap.gt-sm], [fxLayoutGap.gt-md], [fxLayoutGap.gt-lg]\n`\n            },] },\n];\n/** @nocollapse */\nLayoutGapDirective.ctorParameters = () => [\n    { type: MediaMonitor },\n    { type: ElementRef },\n    { type: LayoutDirective, decorators: [{ type: Optional }, { type: Self }] },\n    { type: NgZone },\n    { type: Directionality },\n    { type: StyleUtils }\n];\nLayoutGapDirective.propDecorators = {\n    gap: [{ type: Input, args: ['fxLayoutGap',] }],\n    gapXs: [{ type: Input, args: ['fxLayoutGap.xs',] }],\n    gapSm: [{ type: Input, args: ['fxLayoutGap.sm',] }],\n    gapMd: [{ type: Input, args: ['fxLayoutGap.md',] }],\n    gapLg: [{ type: Input, args: ['fxLayoutGap.lg',] }],\n    gapXl: [{ type: Input, args: ['fxLayoutGap.xl',] }],\n    gapGtXs: [{ type: Input, args: ['fxLayoutGap.gt-xs',] }],\n    gapGtSm: [{ type: Input, args: ['fxLayoutGap.gt-sm',] }],\n    gapGtMd: [{ type: Input, args: ['fxLayoutGap.gt-md',] }],\n    gapGtLg: [{ type: Input, args: ['fxLayoutGap.gt-lg',] }],\n    gapLtSm: [{ type: Input, args: ['fxLayoutGap.lt-sm',] }],\n    gapLtMd: [{ type: Input, args: ['fxLayoutGap.lt-md',] }],\n    gapLtLg: [{ type: Input, args: ['fxLayoutGap.lt-lg',] }],\n    gapLtXl: [{ type: Input, args: ['fxLayoutGap.lt-xl',] }]\n};\n/** @type {?} */\nconst GRID_SPECIFIER = ' grid';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Extends an object with the *enumerable* and *own* properties of one or more source objects,\n * similar to Object.assign.\n *\n * @param {?} dest The object which will have properties copied to it.\n * @param {...?} sources The source objects from which properties will be copied.\n * @return {?}\n */\nfunction extendObject(dest, ...sources) {\n    if (dest == null) {\n        throw TypeError('Cannot convert undefined or null to object');\n    }\n    for (let source of sources) {\n        if (source != null) {\n            for (let key in source) {\n                if (source.hasOwnProperty(key)) {\n                    dest[key] = source[key];\n                }\n            }\n        }\n    }\n    return dest;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Directive to control the size of a flex item using flex-basis, flex-grow, and flex-shrink.\n * Corresponds to the css `flex` shorthand property.\n *\n * @see https://css-tricks.com/snippets/css/a-guide-to-flexbox/\n */\nclass FlexDirective extends BaseDirective {\n    /**\n     * @param {?} monitor\n     * @param {?} elRef\n     * @param {?} _container\n     * @param {?} styleUtils\n     * @param {?} layoutConfig\n     */\n    constructor(monitor, elRef, _container, styleUtils, layoutConfig) {\n        super(monitor, elRef, styleUtils);\n        this._container = _container;\n        this.styleUtils = styleUtils;\n        this.layoutConfig = layoutConfig;\n        this._cacheInput('flex', '');\n        this._cacheInput('shrink', 1);\n        this._cacheInput('grow', 1);\n    }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set shrink(val) { this._cacheInput('shrink', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set grow(val) { this._cacheInput('grow', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set flex(val) { this._cacheInput('flex', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set flexXs(val) { this._cacheInput('flexXs', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set flexSm(val) { this._cacheInput('flexSm', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set flexMd(val) { this._cacheInput('flexMd', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set flexLg(val) { this._cacheInput('flexLg', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set flexXl(val) { this._cacheInput('flexXl', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set flexGtXs(val) { this._cacheInput('flexGtXs', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set flexGtSm(val) { this._cacheInput('flexGtSm', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set flexGtMd(val) { this._cacheInput('flexGtMd', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set flexGtLg(val) { this._cacheInput('flexGtLg', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set flexLtSm(val) { this._cacheInput('flexLtSm', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set flexLtMd(val) { this._cacheInput('flexLtMd', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set flexLtLg(val) { this._cacheInput('flexLtLg', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set flexLtXl(val) { this._cacheInput('flexLtXl', val); }\n    ;\n    /**\n     * For \\@Input changes on the current mq activation property, see onMediaQueryChanges()\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (changes['flex'] != null || this._mqActivation) {\n            this._updateStyle();\n        }\n    }\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n    ngOnInit() {\n        super.ngOnInit();\n        this._listenForMediaQueryChanges('flex', '', (changes) => {\n            this._updateStyle(changes.value);\n        });\n        if (this._container) {\n            // If this flex item is inside of a flex container marked with\n            // Subscribe to layout immediate parent direction changes\n            this._layoutWatcher = this._container.layout$.subscribe((layout) => {\n                // `direction` === null if parent container does not have a `fxLayout`\n                this._onLayoutChange(layout);\n            });\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        super.ngOnDestroy();\n        if (this._layoutWatcher) {\n            this._layoutWatcher.unsubscribe();\n        }\n    }\n    /**\n     * Caches the parent container's 'flex-direction' and updates the element's style.\n     * Used as a handler for layout change events from the parent flex container.\n     * @param {?=} layout\n     * @return {?}\n     */\n    _onLayoutChange(layout) {\n        this._layout = layout || this._layout || { direction: 'row', wrap: false };\n        this._updateStyle();\n    }\n    /**\n     * @param {?=} value\n     * @return {?}\n     */\n    _updateStyle(value) {\n        /** @type {?} */\n        let flexBasis = value || this._queryInput('flex') || '';\n        if (this._mqActivation) {\n            flexBasis = this._mqActivation.activatedInput;\n        }\n        /** @type {?} */\n        let basis = String(flexBasis).replace(';', '');\n        /** @type {?} */\n        let parts = validateBasis(basis, this._queryInput('grow'), this._queryInput('shrink'));\n        this._applyStyleToElement(this._validateValue.apply(this, parts));\n    }\n    /**\n     * Validate the value to be one of the acceptable value options\n     * Use default fallback of 'row'\n     * @param {?} grow\n     * @param {?} shrink\n     * @param {?} basis\n     * @return {?}\n     */\n    _validateValue(grow, shrink, basis) {\n        /** @type {?} */\n        let addFlexToParent = this.layoutConfig.addFlexToParent !== false;\n        /** @type {?} */\n        let layout = this._getFlexFlowDirection(this.parentElement, addFlexToParent);\n        /** @type {?} */\n        let direction = (layout.indexOf('column') > -1) ? 'column' : 'row';\n        /** @type {?} */\n        let max = isFlowHorizontal(direction) ? 'max-width' : 'max-height';\n        /** @type {?} */\n        let min = isFlowHorizontal(direction) ? 'min-width' : 'min-height';\n        /** @type {?} */\n        let hasCalc = String(basis).indexOf('calc') > -1;\n        /** @type {?} */\n        let usingCalc = hasCalc || (basis == 'auto');\n        /** @type {?} */\n        let isPercent = String(basis).indexOf('%') > -1 && !hasCalc;\n        /** @type {?} */\n        let hasUnits = String(basis).indexOf('px') > -1 || String(basis).indexOf('em') > -1 ||\n            String(basis).indexOf('vw') > -1 || String(basis).indexOf('vh') > -1;\n        /** @type {?} */\n        let isPx = String(basis).indexOf('px') > -1 || usingCalc;\n        /** @type {?} */\n        let isValue = (hasCalc || hasUnits);\n        grow = (grow == '0') ? 0 : grow;\n        shrink = (shrink == '0') ? 0 : shrink;\n        /** @type {?} */\n        let isFixed = !grow && !shrink;\n        /** @type {?} */\n        let css = {};\n        /** @type {?} */\n        let clearStyles = {\n            'max-width': null,\n            'max-height': null,\n            'min-width': null,\n            'min-height': null\n        };\n        switch (basis || '') {\n            case '':\n                /** @type {?} */\n                const useColumnBasisZero = this.layoutConfig.useColumnBasisZero !== false;\n                basis = direction === 'row' ? '0%' : (useColumnBasisZero ? '0.000000001px' : 'auto');\n                break;\n            case 'initial': // default\n            case 'nogrow':\n                grow = 0;\n                basis = 'auto';\n                break;\n            case 'grow':\n                basis = '100%';\n                break;\n            case 'noshrink':\n                shrink = 0;\n                basis = 'auto';\n                break;\n            case 'auto':\n                break;\n            case 'none':\n                grow = 0;\n                shrink = 0;\n                basis = 'auto';\n                break;\n            default:\n                // Defaults to percentage sizing unless `px` is explicitly set\n                if (!isValue && !isPercent && !isNaN(/** @type {?} */ (basis))) {\n                    basis = basis + '%';\n                }\n                // Fix for issue 280\n                if (basis === '0%') {\n                    isValue = true;\n                }\n                if (basis === '0px') {\n                    basis = '0%';\n                }\n                // fix issue #5345\n                if (hasCalc) {\n                    css = extendObject(clearStyles, {\n                        'flex-grow': grow,\n                        'flex-shrink': shrink,\n                        'flex-basis': isValue ? basis : '100%'\n                    });\n                }\n                else {\n                    css = extendObject(clearStyles, {\n                        'flex': `${grow} ${shrink} ${isValue ? basis : '100%'}`\n                    });\n                }\n                break;\n        }\n        if (!(css['flex'] || css['flex-grow'])) {\n            if (hasCalc) {\n                css = extendObject(clearStyles, {\n                    'flex-grow': grow,\n                    'flex-shrink': shrink,\n                    'flex-basis': basis\n                });\n            }\n            else {\n                css = extendObject(clearStyles, {\n                    'flex': `${grow} ${shrink} ${basis}`\n                });\n            }\n        }\n        // Fix for issues 277, 534, and 728\n        if (basis !== '0%' && basis !== '0px' && basis !== '0.000000001px' && basis !== 'auto') {\n            css[min] = isFixed || (isPx && grow) ? basis : null;\n            css[max] = isFixed || (!usingCalc && shrink) ? basis : null;\n        }\n        // Fix for issue 528\n        if (!css[min] && !css[max]) {\n            if (hasCalc) {\n                css = extendObject(clearStyles, {\n                    'flex-grow': grow,\n                    'flex-shrink': shrink,\n                    'flex-basis': basis\n                });\n            }\n            else {\n                css = extendObject(clearStyles, {\n                    'flex': `${grow} ${shrink} ${basis}`\n                });\n            }\n        }\n        else {\n            // Fix for issue 660\n            if (this._layout && this._layout.wrap) {\n                css[hasCalc ? 'flex-basis' : 'flex'] = css[max] ?\n                    (hasCalc ? css[max] : `${grow} ${shrink} ${css[max]}`) :\n                    (hasCalc ? css[min] : `${grow} ${shrink} ${css[min]}`);\n            }\n        }\n        return extendObject(css, { 'box-sizing': 'border-box' });\n    }\n}\nFlexDirective.decorators = [\n    { type: Directive, args: [{ selector: `\n  [fxFlex],\n  [fxFlex.xs], [fxFlex.sm], [fxFlex.md], [fxFlex.lg], [fxFlex.xl],\n  [fxFlex.lt-sm], [fxFlex.lt-md], [fxFlex.lt-lg], [fxFlex.lt-xl],\n  [fxFlex.gt-xs], [fxFlex.gt-sm], [fxFlex.gt-md], [fxFlex.gt-lg],\n`\n            },] },\n];\n/** @nocollapse */\nFlexDirective.ctorParameters = () => [\n    { type: MediaMonitor },\n    { type: ElementRef },\n    { type: LayoutDirective, decorators: [{ type: Optional }, { type: SkipSelf }] },\n    { type: StyleUtils },\n    { type: undefined, decorators: [{ type: Inject, args: [LAYOUT_CONFIG,] }] }\n];\nFlexDirective.propDecorators = {\n    shrink: [{ type: Input, args: ['fxShrink',] }],\n    grow: [{ type: Input, args: ['fxGrow',] }],\n    flex: [{ type: Input, args: ['fxFlex',] }],\n    flexXs: [{ type: Input, args: ['fxFlex.xs',] }],\n    flexSm: [{ type: Input, args: ['fxFlex.sm',] }],\n    flexMd: [{ type: Input, args: ['fxFlex.md',] }],\n    flexLg: [{ type: Input, args: ['fxFlex.lg',] }],\n    flexXl: [{ type: Input, args: ['fxFlex.xl',] }],\n    flexGtXs: [{ type: Input, args: ['fxFlex.gt-xs',] }],\n    flexGtSm: [{ type: Input, args: ['fxFlex.gt-sm',] }],\n    flexGtMd: [{ type: Input, args: ['fxFlex.gt-md',] }],\n    flexGtLg: [{ type: Input, args: ['fxFlex.gt-lg',] }],\n    flexLtSm: [{ type: Input, args: ['fxFlex.lt-sm',] }],\n    flexLtMd: [{ type: Input, args: ['fxFlex.lt-md',] }],\n    flexLtLg: [{ type: Input, args: ['fxFlex.lt-lg',] }],\n    flexLtXl: [{ type: Input, args: ['fxFlex.lt-xl',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * 'flex-order' flexbox styling directive\n * Configures the positional ordering of the element in a sorted layout container\n * @see https://css-tricks.com/almanac/properties/o/order/\n */\nclass FlexOrderDirective extends BaseDirective {\n    /**\n     * @param {?} monitor\n     * @param {?} elRef\n     * @param {?} styleUtils\n     */\n    constructor(monitor, elRef, styleUtils) {\n        super(monitor, elRef, styleUtils);\n    }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set order(val) { this._cacheInput('order', val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set orderXs(val) { this._cacheInput('orderXs', val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set orderSm(val) { this._cacheInput('orderSm', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set orderMd(val) { this._cacheInput('orderMd', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set orderLg(val) { this._cacheInput('orderLg', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set orderXl(val) { this._cacheInput('orderXl', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set orderGtXs(val) { this._cacheInput('orderGtXs', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set orderGtSm(val) { this._cacheInput('orderGtSm', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set orderGtMd(val) { this._cacheInput('orderGtMd', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set orderGtLg(val) { this._cacheInput('orderGtLg', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set orderLtSm(val) { this._cacheInput('orderLtSm', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set orderLtMd(val) { this._cacheInput('orderLtMd', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set orderLtLg(val) { this._cacheInput('orderLtLg', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set orderLtXl(val) { this._cacheInput('orderLtXl', val); }\n    ;\n    /**\n     * For \\@Input changes on the current mq activation property, see onMediaQueryChanges()\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (changes['order'] != null || this._mqActivation) {\n            this._updateWithValue();\n        }\n    }\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n    ngOnInit() {\n        super.ngOnInit();\n        this._listenForMediaQueryChanges('order', '0', (changes) => {\n            this._updateWithValue(changes.value);\n        });\n    }\n    /**\n     * @param {?=} value\n     * @return {?}\n     */\n    _updateWithValue(value) {\n        value = value || this._queryInput('order') || '0';\n        if (this._mqActivation) {\n            value = this._mqActivation.activatedInput;\n        }\n        this._applyStyleToElement(this._buildCSS(value));\n    }\n    /**\n     * @param {?=} value\n     * @return {?}\n     */\n    _buildCSS(value = '') {\n        /** @type {?} */\n        const val = parseInt(value, 10);\n        return { order: isNaN(val) ? 0 : val };\n    }\n}\nFlexOrderDirective.decorators = [\n    { type: Directive, args: [{ selector: `\n  [fxFlexOrder],\n  [fxFlexOrder.xs], [fxFlexOrder.sm], [fxFlexOrder.md], [fxFlexOrder.lg], [fxFlexOrder.xl],\n  [fxFlexOrder.lt-sm], [fxFlexOrder.lt-md], [fxFlexOrder.lt-lg], [fxFlexOrder.lt-xl],\n  [fxFlexOrder.gt-xs], [fxFlexOrder.gt-sm], [fxFlexOrder.gt-md], [fxFlexOrder.gt-lg]\n` },] },\n];\n/** @nocollapse */\nFlexOrderDirective.ctorParameters = () => [\n    { type: MediaMonitor },\n    { type: ElementRef },\n    { type: StyleUtils }\n];\nFlexOrderDirective.propDecorators = {\n    order: [{ type: Input, args: ['fxFlexOrder',] }],\n    orderXs: [{ type: Input, args: ['fxFlexOrder.xs',] }],\n    orderSm: [{ type: Input, args: ['fxFlexOrder.sm',] }],\n    orderMd: [{ type: Input, args: ['fxFlexOrder.md',] }],\n    orderLg: [{ type: Input, args: ['fxFlexOrder.lg',] }],\n    orderXl: [{ type: Input, args: ['fxFlexOrder.xl',] }],\n    orderGtXs: [{ type: Input, args: ['fxFlexOrder.gt-xs',] }],\n    orderGtSm: [{ type: Input, args: ['fxFlexOrder.gt-sm',] }],\n    orderGtMd: [{ type: Input, args: ['fxFlexOrder.gt-md',] }],\n    orderGtLg: [{ type: Input, args: ['fxFlexOrder.gt-lg',] }],\n    orderLtSm: [{ type: Input, args: ['fxFlexOrder.lt-sm',] }],\n    orderLtMd: [{ type: Input, args: ['fxFlexOrder.lt-md',] }],\n    orderLtLg: [{ type: Input, args: ['fxFlexOrder.lt-lg',] }],\n    orderLtXl: [{ type: Input, args: ['fxFlexOrder.lt-xl',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * 'flex-offset' flexbox styling directive\n * Configures the 'margin-left' of the element in a layout container\n */\nclass FlexOffsetDirective extends BaseDirective {\n    /**\n     * @param {?} monitor\n     * @param {?} elRef\n     * @param {?} _container\n     * @param {?} _directionality\n     * @param {?} styleUtils\n     */\n    constructor(monitor, elRef, _container, _directionality, styleUtils) {\n        super(monitor, elRef, styleUtils);\n        this._container = _container;\n        this._directionality = _directionality;\n        /**\n         * The flex-direction of this element's host container. Defaults to 'row'.\n         */\n        this._layout = { direction: 'row', wrap: false };\n        this._directionWatcher =\n            this._directionality.change.subscribe(this._updateWithValue.bind(this));\n        this.watchParentFlow();\n    }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set offset(val) { this._cacheInput('offset', val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set offsetXs(val) { this._cacheInput('offsetXs', val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set offsetSm(val) { this._cacheInput('offsetSm', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set offsetMd(val) { this._cacheInput('offsetMd', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set offsetLg(val) { this._cacheInput('offsetLg', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set offsetXl(val) { this._cacheInput('offsetXl', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set offsetLtSm(val) { this._cacheInput('offsetLtSm', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set offsetLtMd(val) { this._cacheInput('offsetLtMd', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set offsetLtLg(val) { this._cacheInput('offsetLtLg', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set offsetLtXl(val) { this._cacheInput('offsetLtXl', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set offsetGtXs(val) { this._cacheInput('offsetGtXs', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set offsetGtSm(val) { this._cacheInput('offsetGtSm', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set offsetGtMd(val) { this._cacheInput('offsetGtMd', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set offsetGtLg(val) { this._cacheInput('offsetGtLg', val); }\n    ;\n    /**\n     * For \\@Input changes on the current mq activation property, see onMediaQueryChanges()\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (changes['offset'] != null || this._mqActivation) {\n            this._updateWithValue();\n        }\n    }\n    /**\n     * Cleanup\n     * @return {?}\n     */\n    ngOnDestroy() {\n        super.ngOnDestroy();\n        if (this._layoutWatcher) {\n            this._layoutWatcher.unsubscribe();\n        }\n        if (this._directionWatcher) {\n            this._directionWatcher.unsubscribe();\n        }\n    }\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n    ngOnInit() {\n        super.ngOnInit();\n        this._listenForMediaQueryChanges('offset', 0, (changes) => {\n            this._updateWithValue(changes.value);\n        });\n    }\n    /**\n     * If parent flow-direction changes, then update the margin property\n     * used to offset\n     * @return {?}\n     */\n    watchParentFlow() {\n        if (this._container) {\n            // Subscribe to layout immediate parent direction changes (if any)\n            this._layoutWatcher = this._container.layout$.subscribe((layout) => {\n                // `direction` === null if parent container does not have a `fxLayout`\n                this._onLayoutChange(layout);\n            });\n        }\n    }\n    /**\n     * Caches the parent container's 'flex-direction' and updates the element's style.\n     * Used as a handler for layout change events from the parent flex container.\n     * @param {?=} layout\n     * @return {?}\n     */\n    _onLayoutChange(layout) {\n        this._layout = layout || this._layout || { direction: 'row', wrap: false };\n        this._updateWithValue();\n    }\n    /**\n     * Using the current fxFlexOffset value, update the inline CSS\n     * NOTE: this will assign `margin-left` if the parent flex-direction == 'row',\n     *       otherwise `margin-top` is used for the offset.\n     * @param {?=} value\n     * @return {?}\n     */\n    _updateWithValue(value) {\n        value = value || this._queryInput('offset') || 0;\n        if (this._mqActivation) {\n            value = this._mqActivation.activatedInput;\n        }\n        this._applyStyleToElement(this._buildCSS(value));\n    }\n    /**\n     * @param {?=} offset\n     * @return {?}\n     */\n    _buildCSS(offset = '') {\n        /** @type {?} */\n        let isPercent = String(offset).indexOf('%') > -1;\n        /** @type {?} */\n        let isPx = String(offset).indexOf('px') > -1;\n        if (!isPx && !isPercent && !isNaN(+offset)) {\n            offset = offset + '%';\n        }\n        /** @type {?} */\n        const isRtl = this._directionality.value === 'rtl';\n        /** @type {?} */\n        const layout = this._getFlexFlowDirection(this.parentElement, true);\n        /** @type {?} */\n        const horizontalLayoutKey = isRtl ? 'margin-right' : 'margin-left';\n        return isFlowHorizontal(layout) ? { [horizontalLayoutKey]: `${offset}` } :\n            { 'margin-top': `${offset}` };\n    }\n}\nFlexOffsetDirective.decorators = [\n    { type: Directive, args: [{ selector: `\n  [fxFlexOffset],\n  [fxFlexOffset.xs], [fxFlexOffset.sm], [fxFlexOffset.md], [fxFlexOffset.lg], [fxFlexOffset.xl],\n  [fxFlexOffset.lt-sm], [fxFlexOffset.lt-md], [fxFlexOffset.lt-lg], [fxFlexOffset.lt-xl],\n  [fxFlexOffset.gt-xs], [fxFlexOffset.gt-sm], [fxFlexOffset.gt-md], [fxFlexOffset.gt-lg]\n` },] },\n];\n/** @nocollapse */\nFlexOffsetDirective.ctorParameters = () => [\n    { type: MediaMonitor },\n    { type: ElementRef },\n    { type: LayoutDirective, decorators: [{ type: Optional }, { type: SkipSelf }] },\n    { type: Directionality },\n    { type: StyleUtils }\n];\nFlexOffsetDirective.propDecorators = {\n    offset: [{ type: Input, args: ['fxFlexOffset',] }],\n    offsetXs: [{ type: Input, args: ['fxFlexOffset.xs',] }],\n    offsetSm: [{ type: Input, args: ['fxFlexOffset.sm',] }],\n    offsetMd: [{ type: Input, args: ['fxFlexOffset.md',] }],\n    offsetLg: [{ type: Input, args: ['fxFlexOffset.lg',] }],\n    offsetXl: [{ type: Input, args: ['fxFlexOffset.xl',] }],\n    offsetLtSm: [{ type: Input, args: ['fxFlexOffset.lt-sm',] }],\n    offsetLtMd: [{ type: Input, args: ['fxFlexOffset.lt-md',] }],\n    offsetLtLg: [{ type: Input, args: ['fxFlexOffset.lt-lg',] }],\n    offsetLtXl: [{ type: Input, args: ['fxFlexOffset.lt-xl',] }],\n    offsetGtXs: [{ type: Input, args: ['fxFlexOffset.gt-xs',] }],\n    offsetGtSm: [{ type: Input, args: ['fxFlexOffset.gt-sm',] }],\n    offsetGtMd: [{ type: Input, args: ['fxFlexOffset.gt-md',] }],\n    offsetGtLg: [{ type: Input, args: ['fxFlexOffset.gt-lg',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * 'flex-align' flexbox styling directive\n * Allows element-specific overrides for cross-axis alignments in a layout container\n * @see https://css-tricks.com/almanac/properties/a/align-self/\n */\nclass FlexAlignDirective extends BaseDirective {\n    /**\n     * @param {?} monitor\n     * @param {?} elRef\n     * @param {?} styleUtils\n     */\n    constructor(monitor, elRef, styleUtils) {\n        super(monitor, elRef, styleUtils);\n    }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set align(val) { this._cacheInput('align', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignXs(val) { this._cacheInput('alignXs', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignSm(val) { this._cacheInput('alignSm', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignMd(val) { this._cacheInput('alignMd', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLg(val) { this._cacheInput('alignLg', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignXl(val) { this._cacheInput('alignXl', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtSm(val) { this._cacheInput('alignLtSm', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtMd(val) { this._cacheInput('alignLtMd', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtLg(val) { this._cacheInput('alignLtLg', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtXl(val) { this._cacheInput('alignLtXl', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtXs(val) { this._cacheInput('alignGtXs', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtSm(val) { this._cacheInput('alignGtSm', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtMd(val) { this._cacheInput('alignGtMd', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtLg(val) { this._cacheInput('alignGtLg', val); }\n    ;\n    /**\n     * For \\@Input changes on the current mq activation property, see onMediaQueryChanges()\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (changes['align'] != null || this._mqActivation) {\n            this._updateWithValue();\n        }\n    }\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n    ngOnInit() {\n        super.ngOnInit();\n        this._listenForMediaQueryChanges('align', 'stretch', (changes) => {\n            this._updateWithValue(changes.value);\n        });\n    }\n    /**\n     * @param {?=} value\n     * @return {?}\n     */\n    _updateWithValue(value) {\n        value = value || this._queryInput('align') || 'stretch';\n        if (this._mqActivation) {\n            value = this._mqActivation.activatedInput;\n        }\n        this._applyStyleToElement(this._buildCSS(value));\n    }\n    /**\n     * @param {?=} align\n     * @return {?}\n     */\n    _buildCSS(align = '') {\n        /** @type {?} */\n        let css = {};\n        // Cross-axis\n        switch (align) {\n            case 'start':\n                css['align-self'] = 'flex-start';\n                break;\n            case 'end':\n                css['align-self'] = 'flex-end';\n                break;\n            default:\n                css['align-self'] = align;\n                break;\n        }\n        return css;\n    }\n}\nFlexAlignDirective.decorators = [\n    { type: Directive, args: [{\n                selector: `\n  [fxFlexAlign],\n  [fxFlexAlign.xs], [fxFlexAlign.sm], [fxFlexAlign.md], [fxFlexAlign.lg], [fxFlexAlign.xl],\n  [fxFlexAlign.lt-sm], [fxFlexAlign.lt-md], [fxFlexAlign.lt-lg], [fxFlexAlign.lt-xl],\n  [fxFlexAlign.gt-xs], [fxFlexAlign.gt-sm], [fxFlexAlign.gt-md], [fxFlexAlign.gt-lg]\n`\n            },] },\n];\n/** @nocollapse */\nFlexAlignDirective.ctorParameters = () => [\n    { type: MediaMonitor },\n    { type: ElementRef },\n    { type: StyleUtils }\n];\nFlexAlignDirective.propDecorators = {\n    align: [{ type: Input, args: ['fxFlexAlign',] }],\n    alignXs: [{ type: Input, args: ['fxFlexAlign.xs',] }],\n    alignSm: [{ type: Input, args: ['fxFlexAlign.sm',] }],\n    alignMd: [{ type: Input, args: ['fxFlexAlign.md',] }],\n    alignLg: [{ type: Input, args: ['fxFlexAlign.lg',] }],\n    alignXl: [{ type: Input, args: ['fxFlexAlign.xl',] }],\n    alignLtSm: [{ type: Input, args: ['fxFlexAlign.lt-sm',] }],\n    alignLtMd: [{ type: Input, args: ['fxFlexAlign.lt-md',] }],\n    alignLtLg: [{ type: Input, args: ['fxFlexAlign.lt-lg',] }],\n    alignLtXl: [{ type: Input, args: ['fxFlexAlign.lt-xl',] }],\n    alignGtXs: [{ type: Input, args: ['fxFlexAlign.gt-xs',] }],\n    alignGtSm: [{ type: Input, args: ['fxFlexAlign.gt-sm',] }],\n    alignGtMd: [{ type: Input, args: ['fxFlexAlign.gt-md',] }],\n    alignGtLg: [{ type: Input, args: ['fxFlexAlign.gt-lg',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst FLEX_FILL_CSS = {\n    'margin': 0,\n    'width': '100%',\n    'height': '100%',\n    'min-width': '100%',\n    'min-height': '100%'\n};\n/**\n * 'fxFill' flexbox styling directive\n *  Maximizes width and height of element in a layout container\n *\n *  NOTE: fxFill is NOT responsive API!!\n */\nclass FlexFillDirective extends BaseDirective {\n    /**\n     * @param {?} monitor\n     * @param {?} elRef\n     * @param {?} styleUtils\n     */\n    constructor(monitor, elRef, styleUtils) {\n        super(monitor, elRef, styleUtils);\n        this.elRef = elRef;\n        this._applyStyleToElement(FLEX_FILL_CSS);\n    }\n}\nFlexFillDirective.decorators = [\n    { type: Directive, args: [{ selector: `\n  [fxFill],\n  [fxFlexFill]\n` },] },\n];\n/** @nocollapse */\nFlexFillDirective.ctorParameters = () => [\n    { type: MediaMonitor },\n    { type: ElementRef },\n    { type: StyleUtils }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * 'layout-align' flexbox styling directive\n *  Defines positioning of child elements along main and cross axis in a layout container\n *  Optional values: {main-axis} values or {main-axis cross-axis} value pairs\n *\n * @see https://css-tricks.com/almanac/properties/j/justify-content/\n * @see https://css-tricks.com/almanac/properties/a/align-items/\n * @see https://css-tricks.com/almanac/properties/a/align-content/\n */\nclass LayoutAlignDirective extends BaseDirective {\n    /**\n     * @param {?} monitor\n     * @param {?} elRef\n     * @param {?} container\n     * @param {?} styleUtils\n     */\n    constructor(monitor, elRef, container, styleUtils) {\n        super(monitor, elRef, styleUtils);\n        this._layout = 'row'; // default flex-direction\n        if (container) { // Subscribe to layout direction changes\n            // Subscribe to layout direction changes\n            this._layoutWatcher = container.layout$.subscribe(this._onLayoutChange.bind(this));\n        }\n    }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set align(val) { this._cacheInput('align', val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignXs(val) { this._cacheInput('alignXs', val); }\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignSm(val) { this._cacheInput('alignSm', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignMd(val) { this._cacheInput('alignMd', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLg(val) { this._cacheInput('alignLg', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignXl(val) { this._cacheInput('alignXl', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtXs(val) { this._cacheInput('alignGtXs', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtSm(val) { this._cacheInput('alignGtSm', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtMd(val) { this._cacheInput('alignGtMd', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignGtLg(val) { this._cacheInput('alignGtLg', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtSm(val) { this._cacheInput('alignLtSm', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtMd(val) { this._cacheInput('alignLtMd', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtLg(val) { this._cacheInput('alignLtLg', val); }\n    ;\n    /**\n     * @param {?} val\n     * @return {?}\n     */\n    set alignLtXl(val) { this._cacheInput('alignLtXl', val); }\n    ;\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (changes['align'] != null || this._mqActivation) {\n            this._updateWithValue();\n        }\n    }\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n    ngOnInit() {\n        super.ngOnInit();\n        this._listenForMediaQueryChanges('align', 'start stretch', (changes) => {\n            this._updateWithValue(changes.value);\n        });\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        super.ngOnDestroy();\n        if (this._layoutWatcher) {\n            this._layoutWatcher.unsubscribe();\n        }\n    }\n    /**\n     *\n     * @param {?=} value\n     * @return {?}\n     */\n    _updateWithValue(value) {\n        value = value || this._queryInput('align') || 'start stretch';\n        if (this._mqActivation) {\n            value = this._mqActivation.activatedInput;\n        }\n        this._applyStyleToElement(this._buildCSS(value));\n        this._allowStretching(value, !this._layout ? 'row' : this._layout);\n    }\n    /**\n     * Cache the parent container 'flex-direction' and update the 'flex' styles\n     * @param {?} layout\n     * @return {?}\n     */\n    _onLayoutChange(layout) {\n        this._layout = (layout.direction || '').toLowerCase();\n        if (!LAYOUT_VALUES.find(x => x === this._layout)) {\n            this._layout = 'row';\n        }\n        /** @type {?} */\n        let value = this._queryInput('align') || 'start stretch';\n        if (this._mqActivation) {\n            value = this._mqActivation.activatedInput;\n        }\n        this._allowStretching(value, this._layout || 'row');\n    }\n    /**\n     * @param {?=} align\n     * @return {?}\n     */\n    _buildCSS(align = '') {\n        /** @type {?} */\n        let css = {};\n        let [main_axis, cross_axis] = align.split(' '); // tslint:disable-line:variable-name\n        // Main axis\n        switch (main_axis) {\n            case 'center':\n                css['justify-content'] = 'center';\n                break;\n            case 'space-around':\n                css['justify-content'] = 'space-around';\n                break;\n            case 'space-between':\n                css['justify-content'] = 'space-between';\n                break;\n            case 'space-evenly':\n                css['justify-content'] = 'space-evenly';\n                break;\n            case 'end':\n            case 'flex-end':\n                css['justify-content'] = 'flex-end';\n                break;\n            case 'start':\n            case 'flex-start':\n            default:\n                css['justify-content'] = 'flex-start'; // default main axis\n                break;\n        }\n        // Cross-axis\n        switch (cross_axis) {\n            case 'start':\n            case 'flex-start':\n                css['align-items'] = css['align-content'] = 'flex-start';\n                break;\n            case 'baseline':\n                css['align-items'] = 'baseline';\n                break;\n            case 'center':\n                css['align-items'] = css['align-content'] = 'center';\n                break;\n            case 'end':\n            case 'flex-end':\n                css['align-items'] = css['align-content'] = 'flex-end';\n                break;\n            case 'stretch':\n            default: // 'stretch'\n                // 'stretch'\n                css['align-items'] = css['align-content'] = 'stretch'; // default cross axis\n                break;\n        }\n        return extendObject(css, {\n            'display': 'flex',\n            'flex-direction': this._layout || 'row',\n            'box-sizing': 'border-box'\n        });\n    }\n    /**\n     * Update container element to 'stretch' as needed...\n     * NOTE: this is only done if the crossAxis is explicitly set to 'stretch'\n     * @param {?=} align\n     * @param {?=} layout\n     * @return {?}\n     */\n    _allowStretching(align = '', layout = '') {\n        let [, cross_axis] = align.split(' '); // tslint:disable-line:variable-name\n        if (cross_axis == 'stretch') {\n            // Use `null` values to remove style\n            this._applyStyleToElement({\n                'box-sizing': 'border-box',\n                'max-width': !isFlowHorizontal(layout) ? '100%' : null,\n                'max-height': isFlowHorizontal(layout) ? '100%' : null\n            });\n        }\n    }\n}\nLayoutAlignDirective.decorators = [\n    { type: Directive, args: [{ selector: `\n  [fxLayoutAlign],\n  [fxLayoutAlign.xs], [fxLayoutAlign.sm], [fxLayoutAlign.md], [fxLayoutAlign.lg],[fxLayoutAlign.xl],\n  [fxLayoutAlign.lt-sm], [fxLayoutAlign.lt-md], [fxLayoutAlign.lt-lg], [fxLayoutAlign.lt-xl],\n  [fxLayoutAlign.gt-xs], [fxLayoutAlign.gt-sm], [fxLayoutAlign.gt-md], [fxLayoutAlign.gt-lg]\n` },] },\n];\n/** @nocollapse */\nLayoutAlignDirective.ctorParameters = () => [\n    { type: MediaMonitor },\n    { type: ElementRef },\n    { type: LayoutDirective, decorators: [{ type: Optional }, { type: Self }] },\n    { type: StyleUtils }\n];\nLayoutAlignDirective.propDecorators = {\n    align: [{ type: Input, args: ['fxLayoutAlign',] }],\n    alignXs: [{ type: Input, args: ['fxLayoutAlign.xs',] }],\n    alignSm: [{ type: Input, args: ['fxLayoutAlign.sm',] }],\n    alignMd: [{ type: Input, args: ['fxLayoutAlign.md',] }],\n    alignLg: [{ type: Input, args: ['fxLayoutAlign.lg',] }],\n    alignXl: [{ type: Input, args: ['fxLayoutAlign.xl',] }],\n    alignGtXs: [{ type: Input, args: ['fxLayoutAlign.gt-xs',] }],\n    alignGtSm: [{ type: Input, args: ['fxLayoutAlign.gt-sm',] }],\n    alignGtMd: [{ type: Input, args: ['fxLayoutAlign.gt-md',] }],\n    alignGtLg: [{ type: Input, args: ['fxLayoutAlign.gt-lg',] }],\n    alignLtSm: [{ type: Input, args: ['fxLayoutAlign.lt-sm',] }],\n    alignLtMd: [{ type: Input, args: ['fxLayoutAlign.lt-md',] }],\n    alignLtLg: [{ type: Input, args: ['fxLayoutAlign.lt-lg',] }],\n    alignLtXl: [{ type: Input, args: ['fxLayoutAlign.lt-xl',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst ALL_DIRECTIVES = [\n    LayoutDirective,\n    LayoutGapDirective,\n    LayoutAlignDirective,\n    FlexDirective,\n    FlexOrderDirective,\n    FlexOffsetDirective,\n    FlexFillDirective,\n    FlexAlignDirective,\n];\n/**\n * *****************************************************************\n * Define module for the Flex API\n * *****************************************************************\n */\nclass FlexModule {\n}\nFlexModule.decorators = [\n    { type: NgModule, args: [{\n                imports: [CoreModule, BidiModule],\n                declarations: [...ALL_DIRECTIVES],\n                exports: [...ALL_DIRECTIVES]\n            },] },\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\nexport { FlexModule, FlexDirective, FlexAlignDirective, FlexFillDirective, FlexOffsetDirective, FlexOrderDirective, LayoutDirective, LayoutAlignDirective, LayoutGapDirective };\n"]}