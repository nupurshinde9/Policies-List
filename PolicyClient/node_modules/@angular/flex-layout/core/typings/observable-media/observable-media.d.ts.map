{"version":3,"file":"observable-media.d.ts","sources":["/Users/abhishekkargawal/Documents/Nupur/policies-list/PolicyClient/node_modules/@angular/flex-layout/core/typings/observable-media/observable-media.d.ts"],"sourcesContent":["import { Observable, PartialObserver, Subscribable, Subscription } from 'rxjs';\nimport { BreakPointRegistry } from '../breakpoints/break-point-registry';\nimport { MediaChange } from '../media-change';\nimport { MatchMedia } from '../match-media/match-media';\n/**\n * Base class for MediaService and pseudo-token for\n */\nexport declare abstract class ObservableMedia implements Subscribable<MediaChange> {\n    abstract isActive(query: string): boolean;\n    abstract asObservable(): Observable<MediaChange>;\n    abstract subscribe(next?: (value: MediaChange) => void, error?: (error: any) => void, complete?: () => void): Subscription;\n    abstract subscribe(observer?: PartialObserver<MediaChange>): Subscription;\n}\n/**\n * Class internalizes a MatchMedia service and exposes an Subscribable and Observable interface.\n\n * This an Observable with that exposes a feature to subscribe to mediaQuery\n * changes and a validator method (`isActive(<alias>)`) to test if a mediaQuery (or alias) is\n * currently active.\n *\n * !! Only mediaChange activations (not de-activations) are announced by the ObservableMedia\n *\n * This class uses the BreakPoint Registry to inject alias information into the raw MediaChange\n * notification. For custom mediaQuery notifications, alias information will not be injected and\n * those fields will be ''.\n *\n * !! This is not an actual Observable. It is a wrapper of an Observable used to publish additional\n * methods like `isActive(<alias>). To access the Observable and use RxJS operators, use\n * `.asObservable()` with syntax like media.asObservable().map(....).\n *\n *  @usage\n *\n *  // RxJS\n *  import {filter} from 'rxjs/operators/filter';\n *  import { ObservableMedia } from '@angular/flex-layout';\n *\n *  @Component({ ... })\n *  export class AppComponent {\n *    status : string = '';\n *\n *    constructor(  media:ObservableMedia ) {\n *      let onChange = (change:MediaChange) => {\n *        this.status = change ? `'${change.mqAlias}' = (${change.mediaQuery})` : '';\n *      };\n *\n *      // Subscribe directly or access observable to use filter/map operators\n *      // e.g.\n *      //      media.subscribe(onChange);\n *\n *      media.asObservable()\n *        .pipe(\n *          filter((change:MediaChange) => true)   // silly noop filter\n *        ).subscribe(onChange);\n *    }\n *  }\n */\nexport declare class MediaService implements ObservableMedia {\n    private breakpoints;\n    private mediaWatcher;\n    /**\n     * Should we announce gt-<xxx> breakpoint activations ?\n     */\n    filterOverlaps: boolean;\n    constructor(breakpoints: BreakPointRegistry, mediaWatcher: MatchMedia);\n    /**\n     * Test if specified query/alias is active.\n     */\n    isActive(alias: string): boolean;\n    /**\n     * Proxy to the Observable subscribe method\n     */\n    subscribe(observerOrNext?: PartialObserver<MediaChange> | ((value: MediaChange) => void), error?: (error: any) => void, complete?: () => void): Subscription;\n    /**\n     * Access to observable for use with operators like\n     * .filter(), .map(), etc.\n     */\n    asObservable(): Observable<MediaChange>;\n    /**\n     * Register all the mediaQueries registered in the BreakPointRegistry\n     * This is needed so subscribers can be auto-notified of all standard, registered\n     * mediaQuery activations\n     */\n    private _registerBreakPoints;\n    /**\n     * Prepare internal observable\n     *\n     * NOTE: the raw MediaChange events [from MatchMedia] do not\n     *       contain important alias information; as such this info\n     *       must be injected into the MediaChange\n     */\n    private _buildObservable;\n    /**\n     * Breakpoint locator by alias\n     */\n    private _findByAlias;\n    /**\n     * Breakpoint locator by mediaQuery\n     */\n    private _findByQuery;\n    /**\n     * Find associated breakpoint (if any)\n     */\n    private _toMediaQuery;\n    private readonly observable$;\n}\nexport declare const ObservableMediaProvider: {\n    provide: typeof ObservableMedia;\n    useClass: typeof MediaService;\n};\n"],"names":[],"mappings":"AAAA;;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiGA;;;;;"}